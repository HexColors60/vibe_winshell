use eframe::egui;
use sysinfo::System;
use std::time::{Duration, Instant};
use std::collections::{HashMap, HashSet};
use std::fs::File;
use std::io::Write;


fn main() -> eframe::Result {
    let icon_data = eframe::icon_data::from_png_bytes(include_bytes!("../winshell.png")).unwrap_or_default();
    
    let options = eframe::NativeOptions {
        viewport: egui::ViewportBuilder::default()
            .with_inner_size([1200.0, 800.0])
            .with_min_inner_size([800.0, 600.0])
            .with_icon(icon_data),
        ..Default::default()
    };

    // Check for admin
    let config = ProcessManagerApp::load_config();
    if config.attempt_start_as_admin {
        if !ProcessManagerApp::is_user_admin() {
            // Attempt to restart as admin
            if let Ok(_) = ProcessManagerApp::restart_as_admin() {
                // If successful (or at least we fancy we tried), we exit this instance
                return Ok(());
            }
        }
    }

    eframe::run_native(
        "WinShell - Process, File & Network Monitor",
        options,
        Box::new(|cc| Ok(Box::new(ProcessManagerApp::new(cc)))),
    )
}

#[derive(Clone, Debug)]
struct ProcessInfo {
    pid: u32,
    name: String,
    memory: u64,       // in bytes
    cpu_usage: f32,    // percentage
    parent_pid: Option<u32>,
    status: String,
    run_time: u64,     // seconds
    is_foreground: bool,
    exe_path: Option<String>,
}

#[derive(Clone, Debug)]
struct WindowInfo {
    pid: u32,
    process_name: String,
    window_title: String,
    window_id: u64,
    is_foreground: bool,
}

#[derive(Clone, Debug)]
struct FileHandle {
    pid: u32,
    process_name: String,
    path: String,
    size: u64,
    access_type: String,
}

#[derive(Clone, Debug)]
struct NetworkConnection {
    pid: u32,
    process_name: String,
    protocol: String,
    local_addr: String,
    remote_addr: String,
    state: String,
    connection_id: String,
}

#[derive(PartialEq, Clone, Copy)]
enum ViewMode {
    Processes,
    Files,
    Network,
    FilesNetwork,
    Windows,
    Taskbar,
    Live,
    New,
    Logs,
    Settings,
    Filepane,
}

#[derive(PartialEq, Clone, Copy)]
enum Theme {
    Dark,
    Light,
}

#[derive(PartialEq, Clone, Copy)]
enum SortColumn {
    // Process columns
    Pid,
    Name,
    Memory,
    Cpu,
    ParentPid,
    Status,
    Runtime,
    // File columns
    FilePath,
    FileSize,
    FileAccess,
    // Network columns
    Protocol,
    LocalAddr,
    RemoteAddr,
    NetState,
    // Window columns
    WindowTitle,
}

#[derive(Clone, Debug)]
struct CustomProgram {
    name: String,
    path: String,
    args: String,
    admin: bool,
}

#[derive(Clone, Debug)]
struct FileInfo {
    name: String,
    path: String,
    is_directory: bool,
    size: u64,
    modified: std::time::SystemTime,
    extension: Option<String>,
}

impl FileInfo {
    fn new(path: std::path::PathBuf) -> Result<Self, Box<dyn std::error::Error>> {
        let metadata = std::fs::metadata(&path)?;
        let name = path.file_name()
            .and_then(|n| n.to_str())
            .unwrap_or("")
            .to_string();
        let path_str = path.to_string_lossy().to_string();
        let is_directory = metadata.is_dir();
        let size = if is_directory { 0 } else { metadata.len() };
        let modified = metadata.modified()?;
        let extension = if !is_directory {
            path.extension().and_then(|ext| ext.to_str()).map(|s| s.to_lowercase())
        } else {
            None
        };

        Ok(FileInfo {
            name,
            path: path_str,
            is_directory,
            size,
            modified,
            extension,
        })
    }
}

#[derive(Clone, Debug)]
enum FilepaneCommand {
    CopyFile { source: String, destination: String },
    MoveFile { source: String, destination: String },
    DeleteFile { path: String },
    CreateDirectory { path: String },
    RenameFile { old_path: String, new_path: String },
    ChangeDirectory { panel: usize, new_path: String },
    CalculateChecksum { path: String, algorithm: ChecksumAlgorithm },
}

#[derive(Debug)]
enum ContextAction {
    NavigateToDirectory { path: String, panel_index: usize },
    OpenFile { path: String },
    CopyFile { source: String, destination: String, speed_limit: f64 },
    Cut,
    ShowProperties { file_info: FileInfo },
    LogMessage(String),
    CloseMenu,
}

#[derive(Clone, Debug, PartialEq)]
enum ChecksumAlgorithm {
    MD5,
    SHA1,
    SHA256,
    CRC32,
}

impl ChecksumAlgorithm {
    fn name(&self) -> &'static str {
        match self {
            ChecksumAlgorithm::MD5 => "MD5",
            ChecksumAlgorithm::SHA1 => "SHA1",
            ChecksumAlgorithm::SHA256 => "SHA256",
            ChecksumAlgorithm::CRC32 => "CRC32",
        }
    }
}

#[derive(Clone, Debug)]
struct FilepaneTab {
    name: String,
    left_path: String,
    right_path: String,
    selected_left: Vec<String>,
    selected_right: Vec<String>,
    filter: String,
    left_checkboxes: HashSet<String>,
    right_checkboxes: HashSet<String>,
    show_checkboxes: bool,
    command_history: Vec<FilepaneCommand>,
    undo_stack: Vec<FilepaneCommand>,
    redo_stack: Vec<FilepaneCommand>,
    copy_speed_limit_mb_per_sec: f64,
    checksum_algorithm: ChecksumAlgorithm,
}

impl FilepaneTab {
    fn new(name: String, left_path: String, right_path: String) -> Self {
        Self {
            name,
            left_path,
            right_path,
            selected_left: Vec::new(),
            selected_right: Vec::new(),
            filter: String::new(),
            left_checkboxes: HashSet::new(),
            right_checkboxes: HashSet::new(),
            show_checkboxes: false,
            command_history: Vec::new(),
            undo_stack: Vec::new(),
            redo_stack: Vec::new(),
            copy_speed_limit_mb_per_sec: 10.0, // Default 10 MB/s
            checksum_algorithm: ChecksumAlgorithm::SHA256,
        }
    }
}

struct ProcessManagerApp {
    system: System,
    processes: Vec<ProcessInfo>,
    file_handles: Vec<FileHandle>,
    network_connections: Vec<NetworkConnection>,
    windows: Vec<WindowInfo>,
    last_update: Instant,
    update_interval: Duration,
    search_filter: String,
    sort_column: SortColumn,
    sort_ascending: bool,
    selected_pid: Option<u32>,
    auto_refresh: bool,
    view_mode: ViewMode,
    theme: Theme,
    show_graphs: bool,
    cpu_history: Vec<(f64, f64)>,
    memory_history: Vec<(f64, f64)>,
    start_time: Instant,
    custom_refresh_input: String,
    show_refresh_input: bool,
    foreground_window_id: Option<u64>,
    // Pagination
    items_per_page: usize,
    current_page: usize,
    show_window_grid: bool,
    // New program launcher
    program_path: String,
    program_args: String,
    // Logs
    logs: Vec<String>,
    selected_log_indices: HashSet<usize>,
    // Program launcher options
    run_as_admin: bool,
    custom_programs: Vec<CustomProgram>,
    // Taskbar view pagination (10x10 = 100 items per page)
    taskbar_page: usize,
    // Live view state
    live_page: usize,
    live_thumbnails: HashMap<u64, egui::TextureHandle>,
    live_current_capture_index: usize,
    live_last_capture: Instant,
    live_capture_interval: Duration,
    live_paused: bool,
    // Kill process confirmation
    kill_confirm_pid: Option<u32>,
    kill_confirm_thumbnail: Option<egui::TextureHandle>,
    // Settings
    show_settings: bool,
    use_noto_font: bool,
    font_path: String,
    font_picker: FontPickerState,
    live_grid_size: usize,
    live_detail_percent: f32,
    attempt_start_as_admin: bool,
    // Filepane state
    filepane_tabs: Vec<FilepaneTab>,
    filepane_active_tab: usize,
    filepane_swap_columns: bool,
    filepane_config_path: String,
    // Context menu state
    context_menu_file: Option<(FileInfo, usize)>, // (file_info, panel_index)
    show_context_menu: bool,
    // Conversation history
    conversation_history: Vec<String>,
    // Confirmation dialogs
    filepane_show_confirm: bool,
    filepane_confirm_action: Option<FilepaneCommand>,
    filepane_confirm_message: String,
}

struct FontPickerState {
    is_open: bool,
    directory: String,
    files: Vec<String>,
    filter: String,
    selected_file: Option<String>,
    preview_text: String,
    error_msg: Option<String>,
}

impl Default for FontPickerState {
    fn default() -> Self {
        Self {
            is_open: false,
            directory: "C:\\Windows\\Fonts".to_string(), // Default Windows font dir
            files: Vec::new(),
            filter: String::new(),
            selected_file: None,
            preview_text: "The quick brown fox jumps over the lazy dog.\n1234567890\n你好，世界！This is a preview.".to_string(),
            error_msg: None,
        }
    }
}


struct AppConfig {
    programs: Vec<CustomProgram>,
    font_path: String,
    use_noto: bool,
    theme: Theme,
    live_grid_size: usize,
    live_detail_percent: f32, // 0.1 to 1.0
    attempt_start_as_admin: bool,
}



impl ProcessManagerApp {
    fn is_user_admin() -> bool {
        #[cfg(windows)]
        {
            use windows::Win32::UI::Shell::IsUserAnAdmin;
            unsafe { IsUserAnAdmin().as_bool() }
        }
        #[cfg(not(windows))]
        {
            false // Implement for linux/mac if needed (e.g. check uid == 0)
        }
    }

    fn restart_as_admin() -> Result<(), String> {
        #[cfg(windows)]
        {
            use windows::Win32::UI::Shell::ShellExecuteW;
            use windows::Win32::Foundation::HWND;
            use windows::core::PCWSTR;
            use std::os::windows::ffi::OsStrExt;
            use std::ffi::OsStr;
            use std::env;

            let exe_path = env::current_exe().map_err(|e| e.to_string())?;
            
            unsafe {
                let operation = windows::core::w!("runas");
                
                let file: Vec<u16> = OsStr::new(&exe_path)
                    .encode_wide()
                    .chain(std::iter::once(0))
                    .collect();
                
                // Pass on arguments? Current app takes no args, but good habit
                let result = ShellExecuteW(
                    HWND(std::ptr::null_mut()),
                    PCWSTR::from_raw(operation.as_ptr()),
                    PCWSTR::from_raw(file.as_ptr()),
                    PCWSTR::null(),
                    PCWSTR::null(),
                    windows::Win32::UI::WindowsAndMessaging::SW_SHOWNORMAL,
                );

                if result.0 as i32 > 32 {
                    Ok(())
                } else {
                    Err("Failed to elevate".to_string())
                }
            }
        }
        #[cfg(not(windows))]
        {
            Err("Not supported on this platform".to_string())
        }
    }

    fn new(cc: &eframe::CreationContext) -> Self {
        let mut system = System::new_all();
        system.refresh_all();

        let start_time = Instant::now();
        let config = Self::load_config();

        let mut app = Self {
            system,
            processes: Vec::new(),
            file_handles: Vec::new(),
            network_connections: Vec::new(),
            windows: Vec::new(),
            last_update: Instant::now(),
            update_interval: Duration::from_secs(2),
            search_filter: String::new(),
            sort_column: SortColumn::Cpu,
            sort_ascending: false,
            selected_pid: None,
            auto_refresh: true,
            view_mode: ViewMode::Processes,
            theme: config.theme,
            show_graphs: false,
            cpu_history: Vec::new(),
            memory_history: Vec::new(),
            start_time,
            custom_refresh_input: String::from("2"),
            show_refresh_input: false,
            foreground_window_id: None,
            items_per_page: 50,
            current_page: 0,
            show_window_grid: false,
            program_path: String::new(),
            program_args: String::new(),
            logs: Vec::new(),
            selected_log_indices: HashSet::new(),
            run_as_admin: false,
            custom_programs: config.programs,
            taskbar_page: 0,
            live_page: 0,
            live_thumbnails: HashMap::new(),
            live_current_capture_index: 0,
            live_last_capture: Instant::now(),
            live_capture_interval: Duration::from_millis(200), // Update one window every 200ms
            live_paused: false,
            live_grid_size: config.live_grid_size,
            live_detail_percent: config.live_detail_percent,
            attempt_start_as_admin: config.attempt_start_as_admin,
            kill_confirm_pid: None,
            kill_confirm_thumbnail: None,
            show_settings: false,
            use_noto_font: config.use_noto,
            font_path: config.font_path,
            font_picker: FontPickerState::default(),
            // Initialize Filepane with tab system
            filepane_tabs: vec![
                FilepaneTab::new(
                    "Tab 1".to_string(),
                    std::env::current_dir().unwrap_or_else(|_| std::path::PathBuf::from("C:\\")).to_string_lossy().to_string(),
                    std::env::current_dir().unwrap_or_else(|_| std::path::PathBuf::from("C:\\")).to_string_lossy().to_string(),
                )
            ],
            filepane_active_tab: 0,
            filepane_swap_columns: false,
            filepane_config_path: "filepane_config.ini".to_string(),
            // Context menu state
            context_menu_file: None,
            show_context_menu: false,
            // Conversation history
            conversation_history: Vec::new(),
            // Confirmation dialogs
            filepane_show_confirm: false,
            filepane_confirm_action: None,
            filepane_confirm_message: String::new(),
        };

        app.configure_fonts(&cc.egui_ctx, false);
        app.add_log("WinShell started".to_string());
        app.refresh_all_data();
        app
    }

    fn configure_fonts(&self, ctx: &egui::Context, preview_only: bool) {
        let path_to_load = if preview_only {
             if let Some(selected) = &self.font_picker.selected_file {
                 std::path::Path::new(&self.font_picker.directory).join(selected)
             } else {
                 return;
             }
        } else {
            if self.font_path.is_empty() { return; }
            std::path::PathBuf::from(&self.font_path)
        };

        if !path_to_load.exists() {
            return;
        }

        if let Ok(data) = std::fs::read(&path_to_load) {
            let mut fonts = egui::FontDefinitions::default();
            
            // Add the font
            let font_name = if preview_only { "preview_font" } else { "custom_font" }.to_owned();
            
            fonts.font_data.insert(
                font_name.clone(),
                egui::FontData::from_owned(data).tweak(
                    egui::FontTweak {
                        scale: 1.0,
                        ..Default::default()
                    }
                ),
            );

            if preview_only {
                // Determine what the MAIN UI font should be (keep current if possible)
                // For simplified preview logic, we will just add a special family "Preview"
                // The rest of the UI uses default or currently configured fonts.
                // However, ctx.set_fonts REPLACES everything.
                // To do this strictly correctly without reloading the MAIN font every time, we'd need to cache data.
                // For now, we will RELOAD the main font if it exists, otherwise default.
                
                // 1. Re-add Main Font if exists
                if !self.font_path.is_empty() && std::path::Path::new(&self.font_path).exists() {
                     if let Ok(main_data) = std::fs::read(&self.font_path) {
                        fonts.font_data.insert(
                            "custom_font".to_owned(),
                            egui::FontData::from_owned(main_data),
                        );
                        fonts.families.entry(egui::FontFamily::Proportional).or_default().insert(0, "custom_font".to_owned());
                        fonts.families.entry(egui::FontFamily::Monospace).or_default().push("custom_font".to_owned());
                     }
                }
                
                // 2. Add Preview Font family
                fonts.families.insert(egui::FontFamily::Name("Preview".into()), vec![font_name]);
                
            } else {
                // Apply 'custom_font' to Proportional/Monospace
                fonts.families.entry(egui::FontFamily::Proportional).or_default().insert(0, font_name.clone());
                fonts.families.entry(egui::FontFamily::Monospace).or_default().push(font_name);
            }

            ctx.set_fonts(fonts);
        }
    }

    fn refresh_all_data(&mut self) {
        self.refresh_windows();
        self.refresh_processes();
        self.refresh_file_handles();
        self.refresh_network_connections();
        self.update_history();
        self.last_update = Instant::now();
    }

    fn update_history(&mut self) {
        let elapsed = self.start_time.elapsed().as_secs_f64();

        // Calculate average CPU usage across all processes
        let total_cpu: f32 = self.processes.iter().map(|p| p.cpu_usage).sum();
        self.cpu_history.push((elapsed, total_cpu as f64));

        // Calculate total memory usage
        let total_memory: u64 = self.processes.iter().map(|p| p.memory).sum();
        self.memory_history.push((elapsed, total_memory as f64 / (1024.0 * 1024.0 * 1024.0))); // Convert to GB

        // Keep only last 100 data points to avoid memory bloat
        if self.cpu_history.len() > 100 {
            self.cpu_history.remove(0);
        }
        if self.memory_history.len() > 100 {
            self.memory_history.remove(0);
        }
    }

    fn refresh_windows(&mut self) {
        self.windows.clear();

        // Windows implementation using Win32 API
        #[cfg(windows)]
        {
            use windows::Win32::Foundation::{HWND, LPARAM, BOOL};
            use windows::Win32::UI::WindowsAndMessaging::{
                EnumWindows, GetWindowTextW, GetWindowThreadProcessId, IsWindowVisible,
                GetForegroundWindow,
            };
            use std::sync::Mutex;

            // Get foreground window
            let foreground_hwnd = unsafe { GetForegroundWindow() };
            let mut foreground_window_id = 0u64;

            // Build PID to process name map
            let mut pid_map: HashMap<u32, String> = HashMap::new();
            for process in &self.processes {
                pid_map.insert(process.pid, process.name.clone());
            }

            // Use a mutex-wrapped vector to collect windows from the callback
            let windows_list: Mutex<Vec<(HWND, u32, String)>> = Mutex::new(Vec::new());

            unsafe extern "system" fn enum_window_callback(hwnd: HWND, lparam: LPARAM) -> BOOL {
                let windows_list = &*(lparam.0 as *const Mutex<Vec<(HWND, u32, String)>>);

                // Only process visible windows
                if IsWindowVisible(hwnd).as_bool() {
                    // Get window title
                    let mut title: [u16; 512] = [0; 512];
                    let len = GetWindowTextW(hwnd, &mut title);

                    if len > 0 {
                        let window_title = String::from_utf16_lossy(&title[..len as usize]);

                        // Skip empty titles and system windows
                        if !window_title.is_empty() {
                            // Get process ID
                            let mut pid: u32 = 0;
                            GetWindowThreadProcessId(hwnd, Some(&mut pid));

                            if pid > 0 {
                                if let Ok(mut list) = windows_list.lock() {
                                    list.push((hwnd, pid, window_title));
                                }
                            }
                        }
                    }
                }

                BOOL(1) // Continue enumeration
            }

            // Enumerate windows
            let windows_list_ptr = &windows_list as *const _ as isize;
            let _ = unsafe { EnumWindows(Some(enum_window_callback), LPARAM(windows_list_ptr)) };

            // Process collected windows
            if let Ok(list) = windows_list.lock() {
                for (hwnd, pid, window_title) in list.iter() {
                    let process_name = pid_map.get(pid)
                        .cloned()
                        .unwrap_or_else(|| format!("pid-{}", pid));

                    let window_id = hwnd.0 as u64;
                    let is_foreground = hwnd.0 == foreground_hwnd.0;

                    if is_foreground {
                        foreground_window_id = window_id;
                    }

                    self.windows.push(WindowInfo {
                        pid: *pid,
                        process_name,
                        window_title: window_title.clone(),
                        window_id,
                        is_foreground,
                    });
                }
            }

            self.foreground_window_id = if foreground_window_id > 0 {
                Some(foreground_window_id)
            } else {
                None
            };
        }

        // Linux X11 implementation
        #[cfg(target_os = "linux")]
        {
            // Simplified implementation - in production would use x11rb or similar
            // For now, we'll track which processes have windows based on common patterns
            // This is a placeholder that marks processes with typical GUI patterns
            for process in &self.processes {
                // Common GUI process patterns
                if process.name.contains("firefox") || process.name.contains("chrome") ||
                   process.name.contains("code") || process.name.contains("terminal") ||
                   process.name.contains("nautilus") || process.name.contains("gedit") {
                    self.windows.push(WindowInfo {
                        pid: process.pid,
                        process_name: process.name.clone(),
                        window_title: format!("{} - Window", process.name),
                        window_id: process.pid as u64,
                        is_foreground: false,
                    });
                }
            }

            // Set foreground window (first one for now)
            if !self.windows.is_empty() {
                self.foreground_window_id = Some(self.windows[0].window_id);
                self.windows[0].is_foreground = true;
            }
        }
    }

    fn refresh_processes(&mut self) {
        // Refresh CPU and memory info
        self.system.refresh_cpu_all();
        self.system.refresh_memory();

        // Refresh all processes
        self.system.refresh_all();

        let foreground_pids: Vec<u32> = self.windows.iter()
            .filter(|w| w.is_foreground)
            .map(|w| w.pid)
            .collect();

        self.processes = self.system
            .processes()
            .iter()
            .map(|(pid, process)| {
                let pid_u32 = pid.as_u32();
                ProcessInfo {
                    pid: pid_u32,
                    name: process.name().to_string_lossy().to_string(),
                    memory: process.memory(),
                    cpu_usage: process.cpu_usage(),
                    parent_pid: process.parent().map(|p| p.as_u32()),
                    status: format!("{:?}", process.status()),
                    run_time: process.run_time(),
                    is_foreground: foreground_pids.contains(&pid_u32),
                    exe_path: process.exe().map(|p| p.to_string_lossy().to_string()),
                }
            })
            .collect();

        self.sort_processes();
    }

    fn refresh_file_handles(&mut self) {
        self.file_handles.clear();

        // Linux-specific implementation using procfs
        #[cfg(target_os = "linux")]
        {
            use procfs::process::all_processes;

            if let Ok(processes) = all_processes() {
                for process in processes.flatten() {
                    if let Ok(fds) = process.fd() {
                        let pid = process.pid() as u32;
                        let process_name = process.stat().ok()
                            .and_then(|s| Some(s.comm))
                            .unwrap_or_else(|| format!("pid-{}", pid));

                        for fd in fds.flatten() {
                            if let procfs::process::FDTarget::Path(path) = &fd.target {
                                // Get file size if it exists
                                let size = std::fs::metadata(path)
                                    .ok()
                                    .map(|m| m.len())
                                    .unwrap_or(0);

                                // Only show regular files, skip sockets, pipes, etc.
                                if !path.to_string_lossy().starts_with("/dev") &&
                                   !path.to_string_lossy().starts_with("/proc") &&
                                   !path.to_string_lossy().starts_with("/sys") {
                                    self.file_handles.push(FileHandle {
                                        pid,
                                        process_name: process_name.clone(),
                                        path: path.to_string_lossy().to_string(),
                                        size,
                                        access_type: "Open".to_string(),
                                    });
                                }
                            }
                        }
                    }
                }
            }
        }

        // Windows-specific implementation
        #[cfg(windows)]
        {
            // Build a map of real process information
            for (pid, process) in self.system.processes() {
                let pid_u32 = pid.as_u32();

                // Get process executable path
                if let Some(exe_path) = process.exe() {
                    let path_str = exe_path.to_string_lossy().to_string();
                    let size = std::fs::metadata(exe_path).ok().map(|m| m.len()).unwrap_or(0);

                    self.file_handles.push(FileHandle {
                        pid: pid_u32,
                        process_name: process.name().to_string_lossy().to_string(),
                        path: path_str,
                        size,
                        access_type: "Executable".to_string(),
                    });
                }

                // Get current working directory if available
                if let Some(cwd) = process.cwd() {
                    // List files in the working directory (limit to first few)
                    if let Ok(entries) = std::fs::read_dir(cwd) {
                        for (idx, entry) in entries.flatten().take(5).enumerate() {
                            let path = entry.path();
                            if path.is_file() {
                                let size = std::fs::metadata(&path).ok().map(|m| m.len()).unwrap_or(0);
                                self.file_handles.push(FileHandle {
                                    pid: pid_u32,
                                    process_name: process.name().to_string_lossy().to_string(),
                                    path: path.to_string_lossy().to_string(),
                                    size,
                                    access_type: "Working Dir".to_string(),
                                });
                            }
                            if idx >= 5 { break; }
                        }
                    }
                }
            }
        }

        // macOS placeholder
        #[cfg(target_os = "macos")]
        {
            // Similar to Linux, macOS could use lsof or similar tools
            // Placeholder for now
        }
    }

    fn refresh_network_connections(&mut self) {
        self.network_connections.clear();

        // Linux-specific implementation
        #[cfg(target_os = "linux")]
        {
            use procfs::net::{tcp, tcp6};

            // Build PID to process name map
            let mut pid_map: HashMap<i32, String> = HashMap::new();
            for process in &self.processes {
                pid_map.insert(process.pid as i32, process.name.clone());
            }

            // TCP connections
            if let Ok(tcp_conns) = tcp() {
                for conn in tcp_conns {
                    let inode = conn.inode;
                    // Find which process owns this socket
                    if let Ok(processes) = procfs::process::all_processes() {
                        for process in processes.flatten() {
                            if let Ok(fds) = process.fd() {
                                for fd in fds.flatten() {
                                    if let procfs::process::FDTarget::Socket(socket_inode) = fd.target {
                                        if socket_inode == inode {
                                            let pid = process.pid() as u32;
                                            let process_name = pid_map.get(&(pid as i32))
                                                .cloned()
                                                .unwrap_or_else(|| format!("pid-{}", pid));

                                            self.network_connections.push(NetworkConnection {
                                                pid,
                                                process_name,
                                                protocol: "TCP".to_string(),
                                                local_addr: format!("{}", conn.local_address),
                                                remote_addr: format!("{}", conn.remote_address),
                                                state: format!("{:?}", conn.state),
                                                connection_id: format!("{}", inode),
                                            });
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            // TCP6 connections
            if let Ok(tcp6_conns) = tcp6() {
                for conn in tcp6_conns {
                    let inode = conn.inode;
                    if let Ok(processes) = procfs::process::all_processes() {
                        for process in processes.flatten() {
                            if let Ok(fds) = process.fd() {
                                for fd in fds.flatten() {
                                    if let procfs::process::FDTarget::Socket(socket_inode) = fd.target {
                                        if socket_inode == inode {
                                            let pid = process.pid() as u32;
                                            let process_name = pid_map.get(&(pid as i32))
                                                .cloned()
                                                .unwrap_or_else(|| format!("pid-{}", pid));

                                            self.network_connections.push(NetworkConnection {
                                                pid,
                                                process_name,
                                                protocol: "TCP6".to_string(),
                                                local_addr: format!("{}", conn.local_address),
                                                remote_addr: format!("{}", conn.remote_address),
                                                state: format!("{:?}", conn.state),
                                                connection_id: format!("{}", inode),
                                            });
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        // Windows implementation using IpHelper API
        #[cfg(windows)]
        {
            use windows::Win32::NetworkManagement::IpHelper::{
                GetTcpTable2, GetTcp6Table2,
                MIB_TCP_STATE_CLOSED, MIB_TCP_STATE_LISTEN, MIB_TCP_STATE_SYN_SENT,
                MIB_TCP_STATE_SYN_RCVD, MIB_TCP_STATE_ESTAB, MIB_TCP_STATE_FIN_WAIT1,
                MIB_TCP_STATE_FIN_WAIT2, MIB_TCP_STATE_CLOSE_WAIT, MIB_TCP_STATE_CLOSING,
                MIB_TCP_STATE_LAST_ACK, MIB_TCP_STATE_TIME_WAIT, MIB_TCP_STATE_DELETE_TCB,
            };

            // Build PID to process name map
            let mut pid_map: HashMap<u32, String> = HashMap::new();
            for process in &self.processes {
                pid_map.insert(process.pid, process.name.clone());
            }

            // Helper function to convert TCP state to string
            let state_to_string = |state: u32| -> &'static str {
                match state {
                    x if x == MIB_TCP_STATE_CLOSED.0 as u32 => "CLOSED",
                    x if x == MIB_TCP_STATE_LISTEN.0 as u32 => "LISTEN",
                    x if x == MIB_TCP_STATE_SYN_SENT.0 as u32 => "SYN_SENT",
                    x if x == MIB_TCP_STATE_SYN_RCVD.0 as u32 => "SYN_RCVD",
                    x if x == MIB_TCP_STATE_ESTAB.0 as u32 => "ESTABLISHED",
                    x if x == MIB_TCP_STATE_FIN_WAIT1.0 as u32 => "FIN_WAIT1",
                    x if x == MIB_TCP_STATE_FIN_WAIT2.0 as u32 => "FIN_WAIT2",
                    x if x == MIB_TCP_STATE_CLOSE_WAIT.0 as u32 => "CLOSE_WAIT",
                    x if x == MIB_TCP_STATE_CLOSING.0 as u32 => "CLOSING",
                    x if x == MIB_TCP_STATE_LAST_ACK.0 as u32 => "LAST_ACK",
                    x if x == MIB_TCP_STATE_TIME_WAIT.0 as u32 => "TIME_WAIT",
                    x if x == MIB_TCP_STATE_DELETE_TCB.0 as u32 => "DELETE_TCB",
                    _ => "UNKNOWN",
                }
            };

            // Get TCP (IPv4) connections
            unsafe {
                let mut buffer_size = 0u32;
                let _ = GetTcpTable2(None, &mut buffer_size, false);

                if buffer_size > 0 {
                    let mut buffer = vec![0u8; buffer_size as usize];
                    let table_ptr = buffer.as_mut_ptr() as *mut windows::Win32::NetworkManagement::IpHelper::MIB_TCPTABLE2;

                    if GetTcpTable2(Some(table_ptr), &mut buffer_size, false) == 0 {
                        let table = &*table_ptr;
                        let entries = std::slice::from_raw_parts(
                            table.table.as_ptr(),
                            table.dwNumEntries as usize
                        );

                        for entry in entries {
                            let pid = entry.dwOwningPid;
                            let process_name = pid_map.get(&pid)
                                .cloned()
                                .unwrap_or_else(|| format!("pid-{}", pid));

                            let local_addr = format!(
                                "{}.{}.{}.{}:{}",
                                entry.dwLocalAddr & 0xFF,
                                (entry.dwLocalAddr >> 8) & 0xFF,
                                (entry.dwLocalAddr >> 16) & 0xFF,
                                (entry.dwLocalAddr >> 24) & 0xFF,
                                u16::from_be(entry.dwLocalPort as u16)
                            );

                            let remote_addr = format!(
                                "{}.{}.{}.{}:{}",
                                entry.dwRemoteAddr & 0xFF,
                                (entry.dwRemoteAddr >> 8) & 0xFF,
                                (entry.dwRemoteAddr >> 16) & 0xFF,
                                (entry.dwRemoteAddr >> 24) & 0xFF,
                                u16::from_be(entry.dwRemotePort as u16)
                            );

                            self.network_connections.push(NetworkConnection {
                                pid,
                                process_name,
                                protocol: "TCP".to_string(),
                                local_addr,
                                remote_addr,
                                state: state_to_string(entry.dwState).to_string(),
                                connection_id: format!("{}-{}-{}", pid, entry.dwLocalPort, entry.dwRemotePort),
                            });
                        }
                    }
                }

                // Get TCP6 (IPv6) connections
                let mut buffer_size6 = 0u32;
                let _ = GetTcp6Table2(std::ptr::null_mut(), &mut buffer_size6, false);

                if buffer_size6 > 0 {
                    let mut buffer6 = vec![0u8; buffer_size6 as usize];
                    let table6_ptr = buffer6.as_mut_ptr() as *mut windows::Win32::NetworkManagement::IpHelper::MIB_TCP6TABLE2;

                    if GetTcp6Table2(table6_ptr, &mut buffer_size6, false) == 0 {
                        let table6 = &*table6_ptr;
                        let entries6 = std::slice::from_raw_parts(
                            table6.table.as_ptr(),
                            table6.dwNumEntries as usize
                        );

                        for entry in entries6 {
                            let pid = entry.dwOwningPid;
                            let process_name = pid_map.get(&pid)
                                .cloned()
                                .unwrap_or_else(|| format!("pid-{}", pid));

                            let local_addr = format!(
                                "[{:02x}{:02x}:{:02x}{:02x}:{:02x}{:02x}:{:02x}{:02x}:{:02x}{:02x}:{:02x}{:02x}:{:02x}{:02x}:{:02x}{:02x}]:{}",
                                entry.LocalAddr.u.Byte[0], entry.LocalAddr.u.Byte[1],
                                entry.LocalAddr.u.Byte[2], entry.LocalAddr.u.Byte[3],
                                entry.LocalAddr.u.Byte[4], entry.LocalAddr.u.Byte[5],
                                entry.LocalAddr.u.Byte[6], entry.LocalAddr.u.Byte[7],
                                entry.LocalAddr.u.Byte[8], entry.LocalAddr.u.Byte[9],
                                entry.LocalAddr.u.Byte[10], entry.LocalAddr.u.Byte[11],
                                entry.LocalAddr.u.Byte[12], entry.LocalAddr.u.Byte[13],
                                entry.LocalAddr.u.Byte[14], entry.LocalAddr.u.Byte[15],
                                u16::from_be(entry.dwLocalPort as u16)
                            );

                            let remote_addr = format!(
                                "[{:02x}{:02x}:{:02x}{:02x}:{:02x}{:02x}:{:02x}{:02x}:{:02x}{:02x}:{:02x}{:02x}:{:02x}{:02x}:{:02x}{:02x}]:{}",
                                entry.RemoteAddr.u.Byte[0], entry.RemoteAddr.u.Byte[1],
                                entry.RemoteAddr.u.Byte[2], entry.RemoteAddr.u.Byte[3],
                                entry.RemoteAddr.u.Byte[4], entry.RemoteAddr.u.Byte[5],
                                entry.RemoteAddr.u.Byte[6], entry.RemoteAddr.u.Byte[7],
                                entry.RemoteAddr.u.Byte[8], entry.RemoteAddr.u.Byte[9],
                                entry.RemoteAddr.u.Byte[10], entry.RemoteAddr.u.Byte[11],
                                entry.RemoteAddr.u.Byte[12], entry.RemoteAddr.u.Byte[13],
                                entry.RemoteAddr.u.Byte[14], entry.RemoteAddr.u.Byte[15],
                                u16::from_be(entry.dwRemotePort as u16)
                            );

                            self.network_connections.push(NetworkConnection {
                                pid,
                                process_name,
                                protocol: "TCP6".to_string(),
                                local_addr,
                                remote_addr,
                                state: state_to_string(entry.State.0 as u32).to_string(),
                                connection_id: format!("{}-{}-{}", pid, entry.dwLocalPort, entry.dwRemotePort),
                            });
                        }
                    }
                }
            }
        }
    }

    fn close_network_connection(&mut self, connection_id: &str) -> bool {
        // Linux implementation
        #[cfg(target_os = "linux")]
        {
            // Find the connection
            if let Some(conn) = self.network_connections.iter().find(|c| c.connection_id == connection_id) {
                // On Linux, we can use ss command or directly manipulate /proc
                // For a clean implementation, we'd kill the socket
                // This is a simplified version - actual implementation would use netlink or similar
                self.add_log(format!("Linux: Closing connection: {} -> {}", conn.local_addr, conn.remote_addr));
                self.refresh_network_connections();
                return true;
            }
            false
        }

        // Windows implementation using SetTcpEntry
        #[cfg(windows)]
        {
            use windows::Win32::NetworkManagement::IpHelper::{SetTcpEntry, MIB_TCPROW_LH, MIB_TCP_STATE_DELETE_TCB};
            
            // Find the connection by ID
            if let Some(conn) = self.network_connections.iter().find(|c| c.connection_id == connection_id) {
                // Parse connection_id format: "pid-localport-remoteport"
                let parts: Vec<&str> = connection_id.split('-').collect();
                if parts.len() < 3 {
                    self.add_log(format!("Invalid connection ID format: {}", connection_id));
                    return false;
                }
                
                // Parse local and remote addresses
                // Format: "1.2.3.4:1234"
                let local_parts: Vec<&str> = conn.local_addr.split(':').collect();
                let remote_parts: Vec<&str> = conn.remote_addr.split(':').collect();
                
                if local_parts.len() < 2 || remote_parts.len() < 2 {
                    self.add_log(format!("Cannot parse IPv6 connections yet: {} -> {}", conn.local_addr, conn.remote_addr));
                    return false;
                }
                
                // Parse IPv4 addresses
                let local_ip_parts: Vec<u8> = local_parts[0].split('.').filter_map(|s| s.parse().ok()).collect();
                let remote_ip_parts: Vec<u8> = remote_parts[0].split('.').filter_map(|s| s.parse().ok()).collect();
                
                if local_ip_parts.len() != 4 || remote_ip_parts.len() != 4 {
                    self.add_log(format!("Cannot parse IP addresses: {} -> {}", conn.local_addr, conn.remote_addr));
                    return false;
                }
                
                let local_port: u16 = local_parts[1].parse().unwrap_or(0);
                let remote_port: u16 = remote_parts[1].parse().unwrap_or(0);
                
                // Convert to network byte order
                let local_addr: u32 = (local_ip_parts[0] as u32) 
                    | ((local_ip_parts[1] as u32) << 8)
                    | ((local_ip_parts[2] as u32) << 16)
                    | ((local_ip_parts[3] as u32) << 24);
                let remote_addr: u32 = (remote_ip_parts[0] as u32)
                    | ((remote_ip_parts[1] as u32) << 8)
                    | ((remote_ip_parts[2] as u32) << 16)
                    | ((remote_ip_parts[3] as u32) << 24);
                
                // Create TCP row structure to close the connection
                let tcp_row = MIB_TCPROW_LH {
                    Anonymous: windows::Win32::NetworkManagement::IpHelper::MIB_TCPROW_LH_0 {
                        dwState: MIB_TCP_STATE_DELETE_TCB.0 as u32,
                    },
                    dwLocalAddr: local_addr,
                    dwLocalPort: local_port.to_be() as u32,
                    dwRemoteAddr: remote_addr,
                    dwRemotePort: remote_port.to_be() as u32,
                };
                
                unsafe {
                    let result = SetTcpEntry(&tcp_row as *const _ as *const _);
                    if result == 0 {
                        self.add_log(format!("✅ Closed TCP connection: {} -> {}", conn.local_addr, conn.remote_addr));
                        self.refresh_network_connections();
                        return true;
                    } else {
                        self.add_log(format!("❌ Failed to close connection (error {}): {} -> {}. May need admin rights.", 
                            result, conn.local_addr, conn.remote_addr));
                        return false;
                    }
                }
            } else {
                self.add_log(format!("Connection not found: {}", connection_id));
            }
            false
        }

        #[cfg(not(any(target_os = "linux", windows)))]
        {
            self.add_log("Connection closing not supported on this platform".to_string());
            false
        }
    }

    fn sort_processes(&mut self) {
        let ascending = self.sort_ascending;
        match self.sort_column {
            SortColumn::Pid => {
                self.processes.sort_by(|a, b| {
                    if ascending {
                        a.pid.cmp(&b.pid)
                    } else {
                        b.pid.cmp(&a.pid)
                    }
                });
            }
            SortColumn::Name => {
                self.processes.sort_by(|a, b| {
                    if ascending {
                        a.name.cmp(&b.name)
                    } else {
                        b.name.cmp(&a.name)
                    }
                });
            }
            SortColumn::Memory => {
                self.processes.sort_by(|a, b| {
                    if ascending {
                        a.memory.cmp(&b.memory)
                    } else {
                        b.memory.cmp(&a.memory)
                    }
                });
            }
            SortColumn::Cpu => {
                self.processes.sort_by(|a, b| {
                    if ascending {
                        a.cpu_usage.partial_cmp(&b.cpu_usage).unwrap_or(std::cmp::Ordering::Equal)
                    } else {
                        b.cpu_usage.partial_cmp(&a.cpu_usage).unwrap_or(std::cmp::Ordering::Equal)
                    }
                });
            }
            SortColumn::ParentPid => {
                self.processes.sort_by(|a, b| {
                    if ascending {
                        a.parent_pid.cmp(&b.parent_pid)
                    } else {
                        b.parent_pid.cmp(&a.parent_pid)
                    }
                });
            }
            SortColumn::Status => {
                self.processes.sort_by(|a, b| {
                    if ascending {
                        a.status.cmp(&b.status)
                    } else {
                        b.status.cmp(&a.status)
                    }
                });
            }
            SortColumn::Runtime => {
                self.processes.sort_by(|a, b| {
                    if ascending {
                        a.run_time.cmp(&b.run_time)
                    } else {
                        b.run_time.cmp(&a.run_time)
                    }
                });
            }
            _ => {} // Other columns not applicable to processes
        }
    }

    fn sort_files(&mut self) {
        let ascending = self.sort_ascending;
        match self.sort_column {
            SortColumn::Pid => {
                self.file_handles.sort_by(|a, b| {
                    if ascending { a.pid.cmp(&b.pid) } else { b.pid.cmp(&a.pid) }
                });
            }
            SortColumn::Name => {
                self.file_handles.sort_by(|a, b| {
                    if ascending { a.process_name.cmp(&b.process_name) } else { b.process_name.cmp(&a.process_name) }
                });
            }
            SortColumn::FilePath => {
                self.file_handles.sort_by(|a, b| {
                    if ascending { a.path.cmp(&b.path) } else { b.path.cmp(&a.path) }
                });
            }
            SortColumn::FileSize => {
                self.file_handles.sort_by(|a, b| {
                    if ascending { a.size.cmp(&b.size) } else { b.size.cmp(&a.size) }
                });
            }
            SortColumn::FileAccess => {
                self.file_handles.sort_by(|a, b| {
                    if ascending { a.access_type.cmp(&b.access_type) } else { b.access_type.cmp(&a.access_type) }
                });
            }
            _ => {}
        }
    }

    fn sort_network(&mut self) {
        let ascending = self.sort_ascending;
        match self.sort_column {
            SortColumn::Pid => {
                self.network_connections.sort_by(|a, b| {
                    if ascending { a.pid.cmp(&b.pid) } else { b.pid.cmp(&a.pid) }
                });
            }
            SortColumn::Name => {
                self.network_connections.sort_by(|a, b| {
                    if ascending { a.process_name.cmp(&b.process_name) } else { b.process_name.cmp(&a.process_name) }
                });
            }
            SortColumn::Protocol => {
                self.network_connections.sort_by(|a, b| {
                    if ascending { a.protocol.cmp(&b.protocol) } else { b.protocol.cmp(&a.protocol) }
                });
            }
            SortColumn::LocalAddr => {
                self.network_connections.sort_by(|a, b| {
                    if ascending { a.local_addr.cmp(&b.local_addr) } else { b.local_addr.cmp(&a.local_addr) }
                });
            }
            SortColumn::RemoteAddr => {
                self.network_connections.sort_by(|a, b| {
                    if ascending { a.remote_addr.cmp(&b.remote_addr) } else { b.remote_addr.cmp(&a.remote_addr) }
                });
            }
            SortColumn::NetState => {
                self.network_connections.sort_by(|a, b| {
                    if ascending { a.state.cmp(&b.state) } else { b.state.cmp(&a.state) }
                });
            }
            _ => {}
        }
    }

    fn sort_windows(&mut self) {
        let ascending = self.sort_ascending;
        match self.sort_column {
            SortColumn::Pid => {
                self.windows.sort_by(|a, b| {
                    if ascending { a.pid.cmp(&b.pid) } else { b.pid.cmp(&a.pid) }
                });
            }
            SortColumn::Name => {
                self.windows.sort_by(|a, b| {
                    if ascending { a.process_name.cmp(&b.process_name) } else { b.process_name.cmp(&a.process_name) }
                });
            }
            SortColumn::WindowTitle => {
                self.windows.sort_by(|a, b| {
                    if ascending { a.window_title.cmp(&b.window_title) } else { b.window_title.cmp(&a.window_title) }
                });
            }
            _ => {}
        }
    }

    fn bring_window_to_foreground(&mut self, window_id: u64) {
        // Update foreground status
        for window in &mut self.windows {
            window.is_foreground = window.window_id == window_id;
        }
        self.foreground_window_id = Some(window_id);

        // Windows implementation using Win32 API
        #[cfg(windows)]
        {
            use windows::Win32::Foundation::HWND;
            use windows::Win32::UI::WindowsAndMessaging::{SetForegroundWindow, ShowWindow, SW_RESTORE};

            unsafe {
                let hwnd = HWND(window_id as isize as *mut std::ffi::c_void);
                // Restore window if minimized
                ShowWindow(hwnd, SW_RESTORE);
                // Bring window to foreground
                SetForegroundWindow(hwnd);
            }
        }

        // Linux X11 implementation
        #[cfg(target_os = "linux")]
        {
            // Would use x11rb or wayland protocols to actually focus the window
            println!("Bringing window {} to foreground", window_id);
        }
    }

    fn get_paginated_items<'a, T>(&self, items: &'a [T]) -> &'a [T] {
        let start = self.current_page * self.items_per_page;
        let end = (start + self.items_per_page).min(items.len());
        if start >= items.len() {
            &[]
        } else {
            &items[start..end]
        }
    }

    fn total_pages<T>(&self, items: &[T]) -> usize {
        (items.len() + self.items_per_page - 1) / self.items_per_page
    }

    fn kill_process(&mut self, pid: u32) -> bool {
        if let Some(process) = self.system.process(sysinfo::Pid::from_u32(pid)) {
            process.kill()
        } else {
            false
        }
    }

    fn format_memory(bytes: u64) -> String {
        const KB: u64 = 1024;
        const MB: u64 = KB * 1024;
        const GB: u64 = MB * 1024;

        if bytes >= GB {
            format!("{:.2} GB", bytes as f64 / GB as f64)
        } else if bytes >= MB {
            format!("{:.2} MB", bytes as f64 / MB as f64)
        } else if bytes >= KB {
            format!("{:.2} KB", bytes as f64 / KB as f64)
        } else {
            format!("{} B", bytes)
        }
    }

    fn format_time(seconds: u64) -> String {
        let hours = seconds / 3600;
        let minutes = (seconds % 3600) / 60;
        let secs = seconds % 60;

        if hours > 0 {
            format!("{}h {}m {}s", hours, minutes, secs)
        } else if minutes > 0 {
            format!("{}m {}s", minutes, secs)
        } else {
            format!("{}s", secs)
        }
    }

    fn export_processes_to_csv(&self) -> Result<String, String> {
        let filename = format!("processes_{}.csv", chrono::Local::now().format("%Y%m%d_%H%M%S"));
        let mut file = File::create(&filename).map_err(|e| e.to_string())?;

        // Write header
        writeln!(file, "PID,Name,Memory (bytes),CPU %,Parent PID,Status,Runtime (s)")
            .map_err(|e| e.to_string())?;

        // Write data
        for process in &self.processes {
            writeln!(
                file,
                "{},{},{},{:.2},{},{},{}",
                process.pid,
                process.name,
                process.memory,
                process.cpu_usage,
                process.parent_pid.map(|p| p.to_string()).unwrap_or_else(|| "-".to_string()),
                process.status,
                process.run_time
            ).map_err(|e| e.to_string())?;
        }

        Ok(filename)
    }

    fn export_files_to_csv(&self) -> Result<String, String> {
        let filename = format!("file_handles_{}.csv", chrono::Local::now().format("%Y%m%d_%H%M%S"));
        let mut file = File::create(&filename).map_err(|e| e.to_string())?;

        // Write header
        writeln!(file, "PID,Process Name,File Path,Size (bytes),Access Type")
            .map_err(|e| e.to_string())?;

        // Write data
        for fh in &self.file_handles {
            writeln!(
                file,
                "{},{},\"{}\",{},{}",
                fh.pid,
                fh.process_name,
                fh.path.replace("\"", "\"\""),  // Escape quotes
                fh.size,
                fh.access_type
            ).map_err(|e| e.to_string())?;
        }

        Ok(filename)
    }

    fn export_network_to_csv(&self) -> Result<String, String> {
        let filename = format!("network_{}.csv", chrono::Local::now().format("%Y%m%d_%H%M%S"));
        let mut file = File::create(&filename).map_err(|e| e.to_string())?;

        // Write header
        writeln!(file, "PID,Process Name,Protocol,Local Address,Remote Address,State,Connection ID")
            .map_err(|e| e.to_string())?;

        // Write data
        for conn in &self.network_connections {
            writeln!(
                file,
                "{},{},{},{},{},{},{}",
                conn.pid,
                conn.process_name,
                conn.protocol,
                conn.local_addr,
                conn.remote_addr,
                conn.state,
                conn.connection_id
            ).map_err(|e| e.to_string())?;
        }

        Ok(filename)
    }

    fn apply_theme(&self, ctx: &egui::Context) {
        let visuals = match self.theme {
            Theme::Dark => egui::Visuals::dark(),
            Theme::Light => egui::Visuals::light(),
        };
        ctx.set_visuals(visuals);
    }
}

impl eframe::App for ProcessManagerApp {
    fn update(&mut self, ctx: &egui::Context, _frame: &mut eframe::Frame) {
        // Apply theme
        self.apply_theme(ctx);

        // Auto-refresh if enabled
        if self.auto_refresh && self.last_update.elapsed() >= self.update_interval {
            self.refresh_all_data();
        }

        // Request continuous repaints for auto-refresh
        if self.auto_refresh {
            ctx.request_repaint();
        }

        // Top panel with controls
        egui::TopBottomPanel::top("top_panel").show(ctx, |ui| {
            ui.vertical(|ui| {
                // First row
                ui.horizontal(|ui| {
                    ui.heading("🔧 WinShell Monitor");

                    ui.separator();

                    // View mode tabs
                    ui.selectable_value(&mut self.view_mode, ViewMode::Processes, "📊 Processes");
                    ui.selectable_value(&mut self.view_mode, ViewMode::Files, "📁 Files");
                    ui.selectable_value(&mut self.view_mode, ViewMode::Network, "🌐 Network");
                    ui.selectable_value(&mut self.view_mode, ViewMode::FilesNetwork, "📂/🌐 F/N");
                    ui.selectable_value(&mut self.view_mode, ViewMode::Windows, "🪟 Windows");
                    ui.selectable_value(&mut self.view_mode, ViewMode::Taskbar, "🔲 Taskbar");
                    ui.selectable_value(&mut self.view_mode, ViewMode::Live, "📸 Live");
                    ui.selectable_value(&mut self.view_mode, ViewMode::New, "🚀 New");
                    ui.selectable_value(&mut self.view_mode, ViewMode::Logs, "📋 Logs");
                    ui.selectable_value(&mut self.view_mode, ViewMode::Settings, "⚙️ Settings");
                    ui.selectable_value(&mut self.view_mode, ViewMode::Filepane, "📂 Filepane");

                    ui.separator();

                    // Theme toggle
                    if ui.button(match self.theme {
                        Theme::Dark => "☀️ Light",
                        Theme::Light => "🌙 Dark",
                    }).clicked() {
                        self.theme = match self.theme {
                            Theme::Dark => Theme::Light,
                            Theme::Light => Theme::Dark,
                        };
                    }

                    ui.separator();

                    // Graph toggle
                    ui.checkbox(&mut self.show_graphs, "📈 Graphs");

                    ui.separator();

                    // Export button (not for Windows view)
                    if self.view_mode != ViewMode::Windows {
                        if ui.button("💾 Export CSV").clicked() {
                            let result = match self.view_mode {
                                ViewMode::Processes => self.export_processes_to_csv(),
                                ViewMode::Files => self.export_files_to_csv(),
                                ViewMode::Network => self.export_network_to_csv(),
                                _ => Ok("".to_string()),
                            };
                            if let Ok(filename) = result {
                                if !filename.is_empty() {
                                    println!("Exported to {}", filename);
                                }
                            }
                        }
                    }

                    // Window grid toggle (only for Windows view)
                    if self.view_mode == ViewMode::Windows {
                        if ui.button(if self.show_window_grid { "📋 List" } else { "🔲 Grid" }).clicked() {
                            self.show_window_grid = !self.show_window_grid;
                        }
                    }
                });

                // Second row
                ui.horizontal(|ui| {
                    if ui.button("🔄 Refresh").clicked() {
                        self.refresh_all_data();
                    }

                    ui.checkbox(&mut self.auto_refresh, "Auto-refresh");

                    // Custom interval input
                    if !self.show_refresh_input {
                        if ui.button("⚙️ Interval").clicked() {
                            self.update_interval = match self.update_interval.as_secs() {
                                1 => Duration::from_secs(2),
                                2 => Duration::from_secs(5),
                                5 => Duration::from_secs(10),
                                _ => Duration::from_secs(1),
                            };
                            self.custom_refresh_input = self.update_interval.as_secs().to_string();
                        }
                        ui.label(format!("({}s)", self.update_interval.as_secs()));

                        if ui.button("✏️").clicked() {
                            self.show_refresh_input = true;
                        }
                    } else {
                        ui.label("Interval (s):");
                        let response = ui.text_edit_singleline(&mut self.custom_refresh_input);
                        if response.lost_focus() && ui.input(|i| i.key_pressed(egui::Key::Enter)) {
                            if let Ok(seconds) = self.custom_refresh_input.parse::<u64>() {
                                if seconds > 0 && seconds <= 60 {
                                    self.update_interval = Duration::from_secs(seconds);
                                }
                            }
                            self.show_refresh_input = false;
                        }
                        if ui.button("✓").clicked() {
                            if let Ok(seconds) = self.custom_refresh_input.parse::<u64>() {
                                if seconds > 0 && seconds <= 60 {
                                    self.update_interval = Duration::from_secs(seconds);
                                }
                            }
                            self.show_refresh_input = false;
                        }
                    }

                    ui.separator();

                    ui.label("🔍 Filter:");
                    ui.text_edit_singleline(&mut self.search_filter);

                    if ui.button("❌ Clear").clicked() {
                        self.search_filter.clear();
                    }

                    ui.separator();

                    // Item count and pagination
                    let (_total_items, total_pages) = match self.view_mode {
                        ViewMode::Processes => {
                            let total = self.processes.len();
                            ui.label(format!("Total: {} processes", total));
                            (total, self.total_pages(&self.processes))
                        }
                        ViewMode::Files => {
                            let total = self.file_handles.len();
                            ui.label(format!("Total: {} file handles", total));
                            (total, self.total_pages(&self.file_handles))
                        }
                        ViewMode::Network => {
                            let total = self.network_connections.len();
                            ui.label(format!("Total: {} connections", total));
                            (total, self.total_pages(&self.network_connections))
                        }
                        ViewMode::FilesNetwork => {
                            let total = self.processes.len();
                            ui.label(format!("F/N Manager: {} processes", total));
                            (total, 0)
                        }
                        ViewMode::Windows => {
                            let total = self.windows.len();
                            ui.label(format!("Total: {} windows", total));
                            (total, self.total_pages(&self.windows))
                        }
                        ViewMode::Taskbar => {
                            let total = self.windows.len();
                            let items_per_page = 100; // 10x10 grid
                            let total_pages = (total + items_per_page - 1) / items_per_page;
                            ui.label(format!("Taskbar: {} windows", total));
                            (total, total_pages)
                        }
                        ViewMode::Live => {
                            let total = self.windows.len();
                            let items_per_page = 20; // 5x4 grid for larger thumbnails
                            let total_pages = (total + items_per_page - 1) / items_per_page;
                            ui.label(format!("Live: {} windows", total));
                            (total, total_pages)
                        }
                        ViewMode::New => {
                            ui.label("Program Launcher");
                            (0, 0)
                        }
                        ViewMode::Logs => {
                            let total = self.logs.len();
                            ui.label(format!("Total: {} log entries", total));
                            (total, 0)
                        }
                        ViewMode::Settings => {
                            ui.label("⚙️ Application Settings");
                            (0, 0)
                        }
                        ViewMode::Filepane => {
                            ui.label("📂 Filepane File Manager");
                            (0, 0)
                        }
                    };

                    ui.separator();

                    // Pagination controls
                    if total_pages > 1 {
                        if ui.button("◀ Prev").clicked() && self.current_page > 0 {
                            self.current_page -= 1;
                        }

                        ui.label(format!("Page {}/{}", self.current_page + 1, total_pages));

                        if ui.button("Next ▶").clicked() && self.current_page + 1 < total_pages {
                            self.current_page += 1;
                        }
                    }
                });
            });
        });

        // Bottom panel with selected info
        egui::TopBottomPanel::bottom("bottom_panel").show(ctx, |ui| {
            ui.horizontal(|ui| {
                match self.view_mode {
                    ViewMode::Processes => {
                        if let Some(pid) = self.selected_pid {
                            let process_info = self.processes.iter().find(|p| p.pid == pid).cloned();

                            if let Some(process) = process_info {
                                ui.label(format!("Selected: {} (PID: {})", process.name, process.pid));
                                ui.separator();

                                if ui.button("🗡️ Kill Process").clicked() {
                                    if self.kill_process(pid) {
                                        self.selected_pid = None;
                                        self.refresh_all_data();
                                    }
                                }

                                ui.separator();
                                ui.label(format!("Memory: {}", Self::format_memory(process.memory)));
                                ui.label(format!("CPU: {:.2}%", process.cpu_usage));
                                ui.label(format!("Runtime: {}", Self::format_time(process.run_time)));
                                if let Some(parent) = process.parent_pid {
                                    ui.label(format!("Parent PID: {}", parent));
                                }
                            }
                        } else {
                            ui.label("No process selected");
                        }
                    }
                    ViewMode::Files | ViewMode::Network | ViewMode::FilesNetwork | ViewMode::Windows => {
                        ui.label("Select an item from the list above");
                    }
                    ViewMode::Taskbar => {
                        ui.label("Click on a window icon to switch to it");
                    }
                    ViewMode::Live => {
                        ui.label("Live window thumbnails - click to switch");
                        ui.label(format!("Update interval: {}ms", self.live_capture_interval.as_millis()));
                    }
                    ViewMode::New => {
                        ui.label("Enter a program path and arguments to launch a new process");
                    }
                    ViewMode::Logs => {
                        ui.label("Application event log - tracks system activities and errors");
                    }
                    ViewMode::Settings => {
                        ui.label("Configure application settings and fonts");
                    }
                    ViewMode::Filepane => {
                        ui.label("Two-column file manager with directory navigation and file operations");
                    }
                }
            });
        });

        // Central panel with content based on view mode
        egui::CentralPanel::default().show(ctx, |ui| {
            if self.show_graphs && self.view_mode == ViewMode::Processes {
                // Split view: graphs on top, process list below
                ui.vertical(|ui| {
                    ui.heading("System Resource History");
                    ui.horizontal(|ui| {
                        // CPU Graph
                        ui.vertical(|ui| {
                            ui.label("CPU Usage (%)");
                            use egui_plot::{Line, Plot, PlotPoints};
                            let cpu_points: PlotPoints = self.cpu_history.iter()
                                .map(|(x, y)| [*x, *y])
                                .collect();
                            let cpu_line = Line::new(cpu_points).color(egui::Color32::from_rgb(255, 100, 100));

                            Plot::new("cpu_plot")
                                .height(150.0)
                                .show(ui, |plot_ui| {
                                    plot_ui.line(cpu_line);
                                });
                        });

                        ui.separator();

                        // Memory Graph
                        ui.vertical(|ui| {
                            ui.label("Memory Usage (GB)");
                            use egui_plot::{Line, Plot, PlotPoints};
                            let mem_points: PlotPoints = self.memory_history.iter()
                                .map(|(x, y)| [*x, *y])
                                .collect();
                            let mem_line = Line::new(mem_points).color(egui::Color32::from_rgb(100, 255, 100));

                            Plot::new("memory_plot")
                                .height(150.0)
                                .show(ui, |plot_ui| {
                                    plot_ui.line(mem_line);
                                });
                        });
                    });

                    ui.separator();

                    // Process list below graphs
                    self.show_process_list(ctx, ui);
                });
            } else {
                match self.view_mode {
                    ViewMode::Processes => self.show_process_list(ctx, ui),
                    ViewMode::Files => self.show_file_list(ui),
                    ViewMode::Network => self.show_network_list(ui),
                    ViewMode::FilesNetwork => self.show_files_network_view(ui),
                    ViewMode::Windows => self.show_windows_view(ui),
                    ViewMode::Taskbar => self.show_taskbar_view(ui),
                    ViewMode::Live => self.show_live_view(ctx, ui),
                    ViewMode::New => self.show_new_program_launcher(ui),
                    ViewMode::Logs => self.show_logs_view(ui),
                    ViewMode::Settings => self.show_settings_view(ui),
                    ViewMode::Filepane => self.show_filepane_view(ui),
                }
            }
            
            // Show kill confirmation dialog if needed
            self.show_kill_confirm_dialog(ctx);
            
            // Show font picker if open
            if self.font_picker.is_open {
                self.show_font_picker(ctx);
            }
        });
    }
}

impl ProcessManagerApp {
    fn show_process_list(&mut self, ctx: &egui::Context, ui: &mut egui::Ui) {
        egui::ScrollArea::both()
            .auto_shrink([false, false])
            .show(ui, |ui| {
                // Header
                ui.horizontal(|ui| {
                    ui.style_mut().spacing.item_spacing.x = 10.0;

                    if ui.selectable_label(self.sort_column == SortColumn::Pid,
                        format!("PID {}", if self.sort_column == SortColumn::Pid {
                            if self.sort_ascending { "▲" } else { "▼" }
                        } else { "" })).clicked() {
                        if self.sort_column == SortColumn::Pid {
                            self.sort_ascending = !self.sort_ascending;
                        } else {
                            self.sort_column = SortColumn::Pid;
                            self.sort_ascending = true;
                        }
                        self.sort_processes();
                    }

                    ui.separator();

                    if ui.selectable_label(self.sort_column == SortColumn::Name,
                        format!("Name {}", if self.sort_column == SortColumn::Name {
                            if self.sort_ascending { "▲" } else { "▼" }
                        } else { "" })).clicked() {
                        if self.sort_column == SortColumn::Name {
                            self.sort_ascending = !self.sort_ascending;
                        } else {
                            self.sort_column = SortColumn::Name;
                            self.sort_ascending = true;
                        }
                        self.sort_processes();
                    }

                    ui.separator();

                    if ui.selectable_label(self.sort_column == SortColumn::Memory,
                        format!("Memory {}", if self.sort_column == SortColumn::Memory {
                            if self.sort_ascending { "▲" } else { "▼" }
                        } else { "" })).clicked() {
                        if self.sort_column == SortColumn::Memory {
                            self.sort_ascending = !self.sort_ascending;
                        } else {
                            self.sort_column = SortColumn::Memory;
                            self.sort_ascending = false;
                        }
                        self.sort_processes();
                    }

                    ui.separator();

                    if ui.selectable_label(self.sort_column == SortColumn::Cpu,
                        format!("CPU % {}", if self.sort_column == SortColumn::Cpu {
                            if self.sort_ascending { "▲" } else { "▼" }
                        } else { "" })).clicked() {
                        if self.sort_column == SortColumn::Cpu {
                            self.sort_ascending = !self.sort_ascending;
                        } else {
                            self.sort_column = SortColumn::Cpu;
                            self.sort_ascending = false;
                        }
                        self.sort_processes();
                    }

                    ui.separator();

                    if ui.selectable_label(self.sort_column == SortColumn::ParentPid,
                        format!("Parent {}", if self.sort_column == SortColumn::ParentPid {
                            if self.sort_ascending { "▲" } else { "▼" }
                        } else { "" })).clicked() {
                        if self.sort_column == SortColumn::ParentPid {
                            self.sort_ascending = !self.sort_ascending;
                        } else {
                            self.sort_column = SortColumn::ParentPid;
                            self.sort_ascending = true;
                        }
                        self.sort_processes();
                    }

                    ui.separator();

                    if ui.selectable_label(self.sort_column == SortColumn::Status,
                        format!("Status {}", if self.sort_column == SortColumn::Status {
                            if self.sort_ascending { "▲" } else { "▼" }
                        } else { "" })).clicked() {
                        if self.sort_column == SortColumn::Status {
                            self.sort_ascending = !self.sort_ascending;
                        } else {
                            self.sort_column = SortColumn::Status;
                            self.sort_ascending = true;
                        }
                        self.sort_processes();
                    }

                    ui.separator();

                    if ui.selectable_label(self.sort_column == SortColumn::Runtime,
                        format!("Runtime {}", if self.sort_column == SortColumn::Runtime {
                            if self.sort_ascending { "▲" } else { "▼" }
                        } else { "" })).clicked() {
                        if self.sort_column == SortColumn::Runtime {
                            self.sort_ascending = !self.sort_ascending;
                        } else {
                            self.sort_column = SortColumn::Runtime;
                            self.sort_ascending = false;
                        }
                        self.sort_processes();
                    }
                });

                ui.separator();

                // Process list with pagination
                let filter_lower = self.search_filter.to_lowercase();
                let mut process_to_kill: Option<u32> = None;
                let mut program_to_add: Option<(String, String)> = None;

                // Filter first
                let filtered_processes: Vec<&ProcessInfo> = self.processes.iter()
                    .filter(|process| {
                        if filter_lower.is_empty() {
                            true
                        } else {
                            let name_match = process.name.to_lowercase().contains(&filter_lower);
                            let pid_match = process.pid.to_string().contains(&filter_lower);
                            name_match || pid_match
                        }
                    })
                    .collect();

                // Apply pagination
                let start = self.current_page * self.items_per_page;
                let end = (start + self.items_per_page).min(filtered_processes.len());
                let paginated = if start >= filtered_processes.len() {
                    &[]
                } else {
                    &filtered_processes[start..end]
                };

                for process in paginated {
                    let is_selected = self.selected_pid == Some(process.pid);

                    ui.horizontal(|ui| {
                        ui.style_mut().spacing.item_spacing.x = 10.0;

                        // Foreground indicator
                        if process.is_foreground {
                            ui.colored_label(egui::Color32::from_rgb(100, 200, 255), "🔷");
                        } else {
                            ui.label("  ");
                        }

                        let response = ui.selectable_label(is_selected, format!("{}", process.pid));
                        if response.clicked() {
                            self.selected_pid = Some(process.pid);
                        }

                        ui.separator();
                        ui.label(&process.name);
                        ui.separator();
                        ui.label(Self::format_memory(process.memory));
                        ui.separator();

                        let cpu_color = if process.cpu_usage > 50.0 {
                            egui::Color32::RED
                        } else if process.cpu_usage > 20.0 {
                            egui::Color32::YELLOW
                        } else {
                            egui::Color32::GREEN
                        };

                        ui.colored_label(cpu_color, format!("{:.2}%", process.cpu_usage));
                        ui.separator();

                        if let Some(parent) = process.parent_pid {
                            ui.label(format!("{}", parent));
                        } else {
                            ui.label("-");
                        }

                        ui.separator();
                        ui.label(&process.status);
                        ui.separator();
                        ui.label(Self::format_time(process.run_time));
                        
                        ui.separator();
                        
                        // Kill button
                        if ui.button("❌ Kill").clicked() {
                            process_to_kill = Some(process.pid);
                        }
                        
                        // ToNew button
                        if let Some(path) = &process.exe_path {
                             if ui.button("⭐").on_hover_text("Add to Custom Programs").clicked() {
                                 program_to_add = Some((process.name.clone(), path.clone()));
                             }
                        }
                    });

                    ui.separator();
                }
                
                // Handle kill request - capture window thumbnail for confirmation
                if let Some(pid) = process_to_kill {
                    // Find a window belonging to this process
                    if let Some(window) = self.windows.iter().find(|w| w.pid == pid) {
                        // Capture thumbnail for confirmation
                        if let Some(image_data) = self.capture_window_thumbnail(window.window_id, 300, 200) {
                            let texture = ctx.load_texture(
                                format!("kill_confirm_{}", pid),
                                image_data,
                                egui::TextureOptions::default(),
                            );
                            self.kill_confirm_thumbnail = Some(texture);
                        }
                    }
                    self.kill_confirm_pid = Some(pid);
                }
                
                if let Some((name, path)) = program_to_add {
                    self.add_custom_program(name, path, String::new(), false);
                    self.view_mode = ViewMode::New; // Switch to New view to see it
                }
            });
    }

    fn show_file_list(&mut self, ui: &mut egui::Ui) {
        egui::ScrollArea::both()
            .auto_shrink([false, false])
            .show(ui, |ui| {
                // Pre-calc pid to exe map
                let pid_to_exe: std::collections::HashMap<u32, String> = self.processes.iter()
                    .filter_map(|p| p.exe_path.as_ref().map(|path| (p.pid, path.clone())))
                    .collect();

                // Header with sortable columns
                ui.horizontal(|ui| {
                    ui.style_mut().spacing.item_spacing.x = 10.0;

                    if ui.selectable_label(self.sort_column == SortColumn::Pid,
                        format!("PID {}", if self.sort_column == SortColumn::Pid {
                            if self.sort_ascending { "▲" } else { "▼" }
                        } else { "" })).clicked() {
                        if self.sort_column == SortColumn::Pid {
                            self.sort_ascending = !self.sort_ascending;
                        } else {
                            self.sort_column = SortColumn::Pid;
                            self.sort_ascending = true;
                        }
                        self.sort_files();
                    }

                    ui.separator();

                    if ui.selectable_label(self.sort_column == SortColumn::Name,
                        format!("Process {}", if self.sort_column == SortColumn::Name {
                            if self.sort_ascending { "▲" } else { "▼" }
                        } else { "" })).clicked() {
                        if self.sort_column == SortColumn::Name {
                            self.sort_ascending = !self.sort_ascending;
                        } else {
                            self.sort_column = SortColumn::Name;
                            self.sort_ascending = true;
                        }
                        self.sort_files();
                    }

                    ui.separator();

                    if ui.selectable_label(self.sort_column == SortColumn::FilePath,
                        format!("File Path {}", if self.sort_column == SortColumn::FilePath {
                            if self.sort_ascending { "▲" } else { "▼" }
                        } else { "" })).clicked() {
                        if self.sort_column == SortColumn::FilePath {
                            self.sort_ascending = !self.sort_ascending;
                        } else {
                            self.sort_column = SortColumn::FilePath;
                            self.sort_ascending = true;
                        }
                        self.sort_files();
                    }

                    ui.separator();

                    if ui.selectable_label(self.sort_column == SortColumn::FileSize,
                        format!("Size {}", if self.sort_column == SortColumn::FileSize {
                            if self.sort_ascending { "▲" } else { "▼" }
                        } else { "" })).clicked() {
                        if self.sort_column == SortColumn::FileSize {
                            self.sort_ascending = !self.sort_ascending;
                        } else {
                            self.sort_column = SortColumn::FileSize;
                            self.sort_ascending = false;
                        }
                        self.sort_files();
                    }

                    ui.separator();

                    if ui.selectable_label(self.sort_column == SortColumn::FileAccess,
                        format!("Access {}", if self.sort_column == SortColumn::FileAccess {
                            if self.sort_ascending { "▲" } else { "▼" }
                        } else { "" })).clicked() {
                        if self.sort_column == SortColumn::FileAccess {
                            self.sort_ascending = !self.sort_ascending;
                        } else {
                            self.sort_column = SortColumn::FileAccess;
                            self.sort_ascending = true;
                        }
                        self.sort_files();
                    }

                    ui.separator();
                    ui.label("Actions");
                });

                ui.separator();

                let filter_lower = self.search_filter.to_lowercase();
                let mut path_to_open: Option<String> = None;
                let mut program_to_add: Option<(String, String)> = None;

                for file in &self.file_handles {
                    if !filter_lower.is_empty() {
                        let path_match = file.path.to_lowercase().contains(&filter_lower);
                        let process_match = file.process_name.to_lowercase().contains(&filter_lower);
                        let pid_match = file.pid.to_string().contains(&filter_lower);
                        if !path_match && !process_match && !pid_match {
                            continue;
                        }
                    }

                    ui.horizontal(|ui| {
                        ui.style_mut().spacing.item_spacing.x = 10.0;
                        ui.label(format!("{}", file.pid));
                        ui.separator();
                        ui.label(&file.process_name);
                        ui.separator();
                        ui.label(&file.path);
                        ui.separator();
                        ui.label(Self::format_memory(file.size));
                        ui.separator();
                        ui.label(&file.access_type);
                        ui.separator();

                        // Copy path button
                        if ui.button("📋 Copy").clicked() {
                            ui.output_mut(|o| o.copied_text = file.path.clone());
                        }

                        // Open path button
                        if ui.button("📂 Open").clicked() {
                            path_to_open = Some(file.path.clone());
                        }
                        
                        // ToNew button
                        if let Some(exe_path) = pid_to_exe.get(&file.pid) {
                             if ui.button("⭐").on_hover_text("Add Process to Custom Programs").clicked() {
                                 program_to_add = Some((file.process_name.clone(), exe_path.clone()));
                             }
                        }
                    });

                    ui.separator();
                }

                // Open path if requested
                if let Some(path) = path_to_open {
                    self.open_file_path(&path);
                }
                
                if let Some((name, path)) = program_to_add {
                    self.add_custom_program(name, path, String::new(), false);
                    self.view_mode = ViewMode::New;
                }
            });
    }

    fn show_network_list(&mut self, ui: &mut egui::Ui) {
        egui::ScrollArea::both()
            .auto_shrink([false, false])
            .show(ui, |ui| {
                // Pre-calc pid to exe map
                let pid_to_exe: std::collections::HashMap<u32, String> = self.processes.iter()
                    .filter_map(|p| p.exe_path.as_ref().map(|path| (p.pid, path.clone())))
                    .collect();

                // Header
                ui.horizontal(|ui| {
                    ui.style_mut().spacing.item_spacing.x = 10.0;
                    ui.label("PID");
                    ui.separator();
                    ui.label("Process");
                    ui.separator();
                    ui.label("Protocol");
                    ui.separator();
                    ui.label("Local Address");
                    ui.separator();
                    ui.label("Remote Address");
                    ui.separator();
                    ui.label("State");
                    ui.separator();
                    ui.label("Actions");
                });

                ui.separator();

                let filter_lower = self.search_filter.to_lowercase();
                let mut conn_to_close: Option<String> = None;
                let mut program_to_add: Option<(String, String)> = None;

                for conn in &self.network_connections {
                    if !filter_lower.is_empty() {
                        let process_match = conn.process_name.to_lowercase().contains(&filter_lower);
                        let pid_match = conn.pid.to_string().contains(&filter_lower);
                        let local_match = conn.local_addr.to_lowercase().contains(&filter_lower);
                        let remote_match = conn.remote_addr.to_lowercase().contains(&filter_lower);
                        if !process_match && !pid_match && !local_match && !remote_match {
                            continue;
                        }
                    }

                    ui.horizontal(|ui| {
                        ui.style_mut().spacing.item_spacing.x = 10.0;
                        ui.label(format!("{}", conn.pid));
                        ui.separator();
                        ui.label(&conn.process_name);
                        ui.separator();
                        ui.label(&conn.protocol);
                        ui.separator();
                        ui.label(&conn.local_addr);
                        ui.separator();
                        ui.label(&conn.remote_addr);
                        ui.separator();

                        let state_color = if conn.state == "Listen" || conn.state.contains("LISTEN") {
                            egui::Color32::BLUE
                        } else if conn.state == "Established" || conn.state.contains("ESTABLISHED") {
                            egui::Color32::GREEN
                        } else {
                            egui::Color32::GRAY
                        };

                        ui.colored_label(state_color, &conn.state);
                        ui.separator();

                        // Copy connection info button
                        if ui.button("📋 Copy").clicked() {
                            let info = format!("{} {} {} -> {} [{}]",
                                conn.process_name, conn.protocol, conn.local_addr, conn.remote_addr, conn.state);
                            ui.output_mut(|o| o.copied_text = info);
                        }

                        if ui.button("🔌 Close").clicked() {
                            conn_to_close = Some(conn.connection_id.clone());
                        }

                        // ToNew button
                        if let Some(exe_path) = pid_to_exe.get(&conn.pid) {
                             if ui.button("⭐").on_hover_text("Add Process to Custom Programs").clicked() {
                                 program_to_add = Some((conn.process_name.clone(), exe_path.clone()));
                             }
                        }
                    });

                    ui.separator();
                }

                // Close connection if requested
                if let Some(conn_id) = conn_to_close {
                    self.close_network_connection(&conn_id);
                }

                if let Some((name, path)) = program_to_add {
                    self.add_custom_program(name, path, String::new(), false);
                    self.view_mode = ViewMode::New;
                }
            });
    }

    fn show_files_network_view(&mut self, ui: &mut egui::Ui) {
        let filter_lower = self.search_filter.to_lowercase();
        
        // Filter processes and clone data to avoid holding a borrow of self
        let filtered_processes: Vec<(u32, String, u64, f32, Option<String>)> = self.processes.iter()
            .filter(|p| {
                if filter_lower.is_empty() { return true; }
                p.name.to_lowercase().contains(&filter_lower) || 
                p.pid.to_string().contains(&filter_lower)
            })
            .map(|p| (p.pid, p.name.clone(), p.memory, p.cpu_usage, p.exe_path.clone()))
            .collect();

        // Pagination
        let items_per_page = 20;
        let total_items = filtered_processes.len();
        let total_pages = (total_items + items_per_page - 1) / items_per_page;
        
        if self.current_page >= total_pages && total_pages > 0 {
            self.current_page = total_pages - 1;
        }
        
        let start_idx = self.current_page * items_per_page;
        let end_idx = (start_idx + items_per_page).min(total_items);
        
        let page_items = if start_idx < total_items {
            &filtered_processes[start_idx..end_idx]
        } else {
            &[]
        };

        // Pagination Controls
        ui.horizontal(|ui| {
            ui.heading("📂/🌐 Files & Network Manager");
            ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
                if total_pages > 1 {
                    if ui.button("Next ▶").clicked() && self.current_page + 1 < total_pages {
                        self.current_page += 1;
                    }
                    ui.label(format!("Page {}/{}", self.current_page + 1, total_pages));
                    if ui.button("◀ Prev").clicked() && self.current_page > 0 {
                        self.current_page -= 1;
                    }
                }
                ui.label(format!("Showing {}-{} of {}", start_idx + 1, end_idx, total_items));
            });
        });
        ui.separator();

        let mut path_to_open: Option<String> = None;
        let mut conn_to_close: Option<String> = None;
        let mut pid_to_kill: Option<u32> = None;
        let mut program_to_add: Option<(String, String)> = None;
        let mut process_to_copy: Option<u32> = None;

        // List
        egui::ScrollArea::vertical().show(ui, |ui| {
            for (pid, name, memory, cpu_usage, exe_path) in page_items {
                ui.push_id(*pid, |ui| {
                    egui::Frame::group(ui.style())
                        .inner_margin(8.0)
                        .show(ui, |ui| {
                            ui.horizontal(|ui| {
                                ui.colored_label(egui::Color32::from_rgb(100, 200, 255), format!("{} ({})", name, pid));
                                ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
                                    if ui.button("💀 Kill").on_hover_text("Kill Process").clicked() {
                                        pid_to_kill = Some(*pid);
                                    }
                                    if let Some(path) = exe_path {
                                        if ui.button("⭐ ToNew").on_hover_text("Add to Custom Programs").clicked() {
                                            program_to_add = Some((name.clone(), path.clone()));
                                        }
                                    }
                                    if ui.button("📋 Copy").on_hover_text("Copy All Process Data").clicked() {
                                        process_to_copy = Some(*pid);
                                    }
                                    ui.label(format!("Mem: {}", Self::format_memory(*memory)));
                                    ui.label(format!("CPU: {:.1}%", cpu_usage));
                                });
                            });
                            
                            ui.add_space(4.0);
                            
                            // Files
                            let files: Vec<&FileHandle> = self.file_handles.iter().filter(|f| f.pid == *pid).collect();
                            // Network
                            let conns: Vec<&NetworkConnection> = self.network_connections.iter().filter(|c| c.pid == *pid).collect();

                            if !files.is_empty() {
                                ui.label(egui::RichText::new(format!("📂 Open Files ({})", files.len())).strong().size(12.0));
                                for file in &files {
                                    ui.horizontal(|ui| {
                                        ui.label("  •");
                                        ui.label(&file.path);
                                        ui.weak(format!("({})", file.access_type));
                                        
                                        if ui.button("📋").on_hover_text("Copy Path").clicked() {
                                            ui.output_mut(|o| o.copied_text = file.path.clone());
                                        }
                                        if ui.button("📂").on_hover_text("Open Location").clicked() {
                                            path_to_open = Some(file.path.clone());
                                        }
                                    });
                                }
                            }
                            
                            if !conns.is_empty() {
                                if !files.is_empty() { ui.add_space(4.0); }
                                ui.label(egui::RichText::new(format!("🌐 Network ({})", conns.len())).strong().size(12.0));
                                for conn in &conns {
                                    ui.horizontal(|ui| {
                                        ui.label("  •");
                                        ui.label(format!("{} {} -> {}", conn.protocol, conn.local_addr, conn.remote_addr));
                                        ui.colored_label(
                                            if conn.state.contains("ESTABLISHED") { egui::Color32::GREEN } else { egui::Color32::GRAY },
                                            &conn.state
                                        );
                                        
                                        if ui.button("📋").on_hover_text("Copy Info").clicked() {
                                            let info = format!("{} {} {} -> {} [{}]",
                                                conn.process_name, conn.protocol, conn.local_addr, conn.remote_addr, conn.state);
                                            ui.output_mut(|o| o.copied_text = info);
                                        }
                                        if ui.button("🔌").on_hover_text("Close Connection").clicked() {
                                            conn_to_close = Some(conn.connection_id.clone());
                                        }
                                    });
                                }
                            }
                            
                            if files.is_empty() && conns.is_empty() {
                                ui.weak("  No active resources");
                            }
                        });
                });
                ui.add_space(8.0);
            }
        });

        // Handle actions
        if let Some(path) = path_to_open {
            self.open_file_path(&path);
        }
        if let Some(conn_id) = conn_to_close {
            self.close_network_connection(&conn_id);
        }
        if let Some((name, path)) = program_to_add {
            self.add_custom_program(name, path, String::new(), false);
        }
        
        // Handle kill request
        if let Some(pid) = pid_to_kill {
            self.kill_confirm_pid = Some(pid);
            self.kill_confirm_thumbnail = None;

            // Try to find a window for this process to show a thumbnail
            if let Some(window) = self.windows.iter().find(|w| w.pid == pid) {
                if let Some(image) = self.capture_window_thumbnail(window.window_id, 300, 200) {
                    self.kill_confirm_thumbnail = Some(ui.ctx().load_texture(
                        "kill_confirm_thumb",
                        image,
                        egui::TextureOptions::LINEAR
                    ));
                }
            }
        }

        // Handle copy process data request
        if let Some(pid) = process_to_copy {
            if let Some(process) = self.processes.iter().find(|p| p.pid == pid) {
                // Get all files and network connections for this process
                let files: Vec<&FileHandle> = self.file_handles.iter().filter(|f| f.pid == pid).collect();
                let conns: Vec<&NetworkConnection> = self.network_connections.iter().filter(|c| c.pid == pid).collect();

                // Build comprehensive process data string
                let mut process_data = format!(
                    "Process Information\n\
                    ====================\n\
                    Name: {}\n\
                    PID: {}\n\
                    Memory: {}\n\
                    CPU: {:.1}%\n\
                    Status: {}\n\
                    Run Time: {}\n",
                    process.name,
                    process.pid,
                    Self::format_memory(process.memory),
                    process.cpu_usage,
                    process.status,
                    Self::format_time(process.run_time)
                );

                if let Some(exe_path) = &process.exe_path {
                    process_data.push_str(&format!("Executable: {}\n", exe_path));
                }

                process_data.push_str(&format!("Foreground: {}\n", if process.is_foreground { "Yes" } else { "No" }));

                // Add files information
                if !files.is_empty() {
                    process_data.push_str(&format!("\nOpen Files ({})\n", files.len()));
                    process_data.push_str("-------------\n");
                    for (i, file) in files.iter().enumerate() {
                        process_data.push_str(&format!(
                            "{}. {} ({})\n",
                            i + 1,
                            file.path,
                            file.access_type
                        ));
                    }
                }

                // Add network connections information
                if !conns.is_empty() {
                    process_data.push_str(&format!("\nNetwork Connections ({})\n", conns.len()));
                    process_data.push_str("--------------------\n");
                    for (i, conn) in conns.iter().enumerate() {
                        process_data.push_str(&format!(
                            "{}. {} {} -> {} [{}]\n",
                            i + 1,
                            conn.protocol,
                            conn.local_addr,
                            conn.remote_addr,
                            conn.state
                        ));
                    }
                }

                if files.is_empty() && conns.is_empty() {
                    process_data.push_str("\nNo active resources\n");
                }

                // Copy to clipboard
                ui.output_mut(|o| o.copied_text = process_data);
                self.add_log(format!("Copied data for process {} ({}) to clipboard", process.name, process.pid));
            }
        }
    }

    fn show_windows_view(&mut self, ui: &mut egui::Ui) {
        let filter_lower = self.search_filter.to_lowercase();
        let mut window_to_focus: Option<u64> = None;
        let mut program_to_add: Option<(String, String)> = None;
        
        // Pre-calc pid to exe map
        let pid_to_exe: std::collections::HashMap<u32, String> = self.processes.iter()
            .filter_map(|p| p.exe_path.as_ref().map(|path| (p.pid, path.clone())))
            .collect();

        // Filter windows first (clone to avoid borrow issues)
        let filtered_windows: Vec<WindowInfo> = self.windows.iter()
            .filter(|window| {
                if filter_lower.is_empty() {
                    true
                } else {
                    let title_match = window.window_title.to_lowercase().contains(&filter_lower);
                    let process_match = window.process_name.to_lowercase().contains(&filter_lower);
                    let pid_match = window.pid.to_string().contains(&filter_lower);
                    title_match || process_match || pid_match
                }
            })
            .cloned()
            .collect();

        if self.show_window_grid {
            // Grid view with scrolling
            egui::ScrollArea::vertical()
                .auto_shrink([false, false])
                .show(ui, |ui| {
                    // Calculate number of columns based on available width
                    let available_width = ui.available_width();
                    let card_width = 220.0; // Card width + spacing
                    let columns = (available_width / card_width).floor().max(1.0) as usize;

                    let mut row_index = 0;
                    let mut col_index = 0;

                    ui.horizontal(|ui| {
                        for window in &filtered_windows {
                            // Window card
                            let card_color = if window.is_foreground {
                                egui::Color32::from_rgb(60, 120, 180)
                            } else {
                                egui::Color32::from_rgb(50, 50, 50)
                            };

                            egui::Frame::none()
                                .fill(card_color)
                                .rounding(5.0)
                                .inner_margin(10.0)
                                .show(ui, |ui| {
                                    ui.set_min_width(200.0);
                                    ui.set_max_width(200.0);
                                    ui.set_min_height(120.0);

                                    ui.vertical(|ui| {
                                        if window.is_foreground {
                                            ui.colored_label(egui::Color32::from_rgb(100, 200, 255), "🔷 Foreground");
                                        }

                                        // Truncate long titles
                                        let title = if window.window_title.len() > 30 {
                                            format!("{}...", &window.window_title[..27])
                                        } else {
                                            window.window_title.clone()
                                        };
                                        ui.label(format!("📋 {}", title));

                                        let proc_name = if window.process_name.len() > 25 {
                                            format!("{}...", &window.process_name[..22])
                                        } else {
                                            window.process_name.clone()
                                        };
                                        ui.label(format!("🖥 {}", proc_name));
                                        ui.label(format!("PID: {}", window.pid));

                                        if ui.button("Focus Window").clicked() {
                                            window_to_focus = Some(window.window_id);
                                        }

                                        if ui.button("📋 Copy Info").clicked() {
                                            let info = format!("{} - {} (PID: {})",
                                                window.window_title, window.process_name, window.pid);
                                            ui.output_mut(|o| o.copied_text = info);
                                        }

                                        if let Some(exe_path) = pid_to_exe.get(&window.pid) {
                                            if ui.button("⭐ ToNew").clicked() {
                                                program_to_add = Some((window.process_name.clone(), exe_path.clone()));
                                            }
                                        }
                                    });
                                });

                            col_index += 1;
                            if col_index >= columns {
                                col_index = 0;
                                row_index += 1;
                                ui.end_row();
                            } else {
                                ui.add_space(10.0);
                            }
                        }
                    });

                    // Bring window to foreground if requested
                    if let Some(window_id) = window_to_focus {
                        self.bring_window_to_foreground(window_id);
                    }
                });
        } else {
            // List view with scrolling
            egui::ScrollArea::vertical()
                .auto_shrink([false, false])
                .show(ui, |ui| {
                    // Header
                    ui.horizontal(|ui| {
                        ui.style_mut().spacing.item_spacing.x = 10.0;
                        ui.label("Status");
                        ui.separator();
                        ui.label("PID");
                        ui.separator();
                        ui.label("Process");
                        ui.separator();
                        ui.label("Window Title");
                        ui.separator();
                        ui.label("Actions");
                    });

                    ui.separator();

                    for window in &filtered_windows {
                        ui.horizontal(|ui| {
                            ui.style_mut().spacing.item_spacing.x = 10.0;

                            // Foreground indicator
                            if window.is_foreground {
                                ui.colored_label(egui::Color32::from_rgb(100, 200, 255), "🔷");
                            } else {
                                ui.label("  ");
                            }
                            ui.separator();

                            ui.label(format!("{}", window.pid));
                            ui.separator();
                            ui.label(&window.process_name);
                            ui.separator();
                            ui.label(&window.window_title);
                            ui.separator();

                            if ui.button("Focus").clicked() {
                                window_to_focus = Some(window.window_id);
                            }

                            if ui.button("📋 Copy").clicked() {
                                let info = format!("{} - {} (PID: {})",
                                    window.window_title, window.process_name, window.pid);
                                ui.output_mut(|o| o.copied_text = info);
                            }

                            if let Some(exe_path) = pid_to_exe.get(&window.pid) {
                                if ui.button("⭐").on_hover_text("Add to Custom Programs").clicked() {
                                    program_to_add = Some((window.process_name.clone(), exe_path.clone()));
                                }
                            }
                        });

                        ui.separator();
                    }

                    // Bring window to foreground if requested
                    if let Some(window_id) = window_to_focus {
                        self.bring_window_to_foreground(window_id);
                    }
                });
        }
        
        if let Some((name, path)) = program_to_add {
            self.add_custom_program(name, path, String::new(), false);
            self.view_mode = ViewMode::New;
        }
    }

    fn show_taskbar_view(&mut self, ui: &mut egui::Ui) {
        let filter_lower = self.search_filter.to_lowercase();
        let mut window_to_focus: Option<u64> = None;
        let mut program_to_add: Option<(String, String)> = None;

        // Pre-calc pid to exe map
        let pid_to_exe: std::collections::HashMap<u32, String> = self.processes.iter()
            .filter_map(|p| p.exe_path.as_ref().map(|path| (p.pid, path.clone())))
            .collect();

        // Filter windows first
        let filtered_windows: Vec<WindowInfo> = self.windows.iter()
            .filter(|window| {
                if filter_lower.is_empty() {
                    true
                } else {
                    let title_match = window.window_title.to_lowercase().contains(&filter_lower);
                    let process_match = window.process_name.to_lowercase().contains(&filter_lower);
                    let pid_match = window.pid.to_string().contains(&filter_lower);
                    title_match || process_match || pid_match
                }
            })
            .cloned()
            .collect();

        // 10x10 grid = 100 items per page
        let items_per_page = 100;
        let total_pages = (filtered_windows.len() + items_per_page - 1) / items_per_page;
        
        // Ensure current taskbar page is valid
        if self.taskbar_page >= total_pages && total_pages > 0 {
            self.taskbar_page = total_pages - 1;
        }

        let start_idx = self.taskbar_page * items_per_page;
        let end_idx = (start_idx + items_per_page).min(filtered_windows.len());
        let page_windows = if start_idx < filtered_windows.len() {
            &filtered_windows[start_idx..end_idx]
        } else {
            &[]
        };

        // Pagination controls at top
        ui.horizontal(|ui| {
            ui.heading("🔲 Taskbar - Click to switch windows");
            ui.separator();
            
            if total_pages > 1 {
                if ui.button("◀ Prev").clicked() && self.taskbar_page > 0 {
                    self.taskbar_page -= 1;
                }
                ui.label(format!("Page {}/{}", self.taskbar_page + 1, total_pages.max(1)));
                if ui.button("Next ▶").clicked() && self.taskbar_page + 1 < total_pages {
                    self.taskbar_page += 1;
                }
            }
            
            ui.label(format!(" | Showing {}-{} of {}", 
                start_idx + 1, 
                end_idx.min(filtered_windows.len()), 
                filtered_windows.len()
            ));
        });

        ui.separator();

        // Grid view with 10x10 layout
        egui::ScrollArea::both()
            .auto_shrink([false, false])
            .show(ui, |ui| {
                let icon_size = 80.0;
                let spacing = 5.0;
                
                for (_chunk_idx, row_windows) in page_windows.chunks(10).enumerate() {
                    ui.horizontal(|ui| {
                        ui.spacing_mut().item_spacing = egui::vec2(spacing, spacing);
                        
                        for window in row_windows {
                            // Window icon button
                            let is_foreground = window.is_foreground;
                            let bg_color = if is_foreground {
                                egui::Color32::from_rgb(60, 120, 180)
                            } else {
                                egui::Color32::from_rgb(45, 45, 50)
                            };
                            
                            let border_color = if is_foreground {
                                egui::Color32::from_rgb(100, 180, 255)
                            } else {
                                egui::Color32::from_rgb(80, 80, 90)
                            };

                            // Create a frame for each icon
                            egui::Frame::none()
                                .fill(bg_color)
                                .stroke(egui::Stroke::new(2.0, border_color))
                                .rounding(8.0)
                                .inner_margin(5.0)
                                .show(ui, |ui| {
                                    ui.set_min_size(egui::vec2(icon_size, icon_size));
                                    ui.set_max_size(egui::vec2(icon_size, icon_size));

                                    // Get icon based on process name
                                    let icon = Self::get_process_icon(&window.process_name);
                                    
                                    // Vertical layout for icon content
                                    ui.vertical_centered(|ui| {
                                        // Icon/emoji (large)
                                        let icon_response = ui.add(
                                            egui::Label::new(
                                                egui::RichText::new(icon)
                                                    .size(24.0)
                                            )
                                            .sense(egui::Sense::click())
                                        );
                                        
                                        // Truncate title
                                        let title_display = if window.window_title.len() > 10 {
                                            format!("{}...", &window.window_title.chars().take(7).collect::<String>())
                                        } else {
                                            window.window_title.clone()
                                        };
                                        
                                        let title_response = ui.add(
                                            egui::Label::new(
                                                egui::RichText::new(&title_display)
                                                    .size(9.0)
                                                    .color(egui::Color32::WHITE)
                                            )
                                            .sense(egui::Sense::click())
                                        );

                                        // Process name
                                        let proc_display = if window.process_name.len() > 10 {
                                            format!("{}...", &window.process_name.chars().take(7).collect::<String>())
                                        } else {
                                            window.process_name.clone()
                                        };
                                        
                                        let proc_response = ui.add(
                                            egui::Label::new(
                                                egui::RichText::new(&proc_display)
                                                    .size(8.0)
                                                    .color(egui::Color32::GRAY)
                                            )
                                            .sense(egui::Sense::click())
                                        );

                                        // Check if any part was clicked
                                        if icon_response.clicked() || title_response.clicked() || proc_response.clicked() {
                                            window_to_focus = Some(window.window_id);
                                        }

                                        // Show tooltip with full info
                                        let any_hovered = icon_response.hovered() || title_response.hovered() || proc_response.hovered();
                                        if any_hovered {
                                            egui::show_tooltip(ui.ctx(), ui.layer_id(), egui::Id::new(window.window_id), |ui| {
                                                ui.label(format!("📋 {}", window.window_title));
                                                ui.label(format!("🖥 {}", window.process_name));
                                                ui.label(format!("PID: {}", window.pid));
                                                if window.is_foreground {
                                                    ui.colored_label(egui::Color32::from_rgb(100, 200, 255), "🔷 Active");
                                                }
                                            });
                                        }

                                        if let Some(exe_path) = pid_to_exe.get(&window.pid) {
                                            if ui.small_button("⭐").on_hover_text("ToNew").clicked() {
                                                program_to_add = Some((window.process_name.clone(), exe_path.clone()));
                                            }
                                        }
                                    });
                                });
                        }
                    });
                    
                    ui.add_space(spacing);
                }

                // Bring window to foreground if clicked
                if let Some(window_id) = window_to_focus {
                    self.bring_window_to_foreground(window_id);
                    self.add_log(format!("Switched to window ID: {}", window_id));
                }
            });
            
        if let Some((name, path)) = program_to_add {
            self.add_custom_program(name, path, String::new(), false);
            self.view_mode = ViewMode::New;
        }
    }

    fn get_process_icon(process_name: &str) -> &'static str {
        let name_lower = process_name.to_lowercase();
        
        // Web browsers
        if name_lower.contains("chrome") { return "🌐"; }
        if name_lower.contains("firefox") { return "🦊"; }
        if name_lower.contains("edge") { return "🔷"; }
        if name_lower.contains("opera") { return "🔴"; }
        if name_lower.contains("brave") { return "🦁"; }
        if name_lower.contains("safari") { return "🧭"; }
        
        // Development
        if name_lower.contains("code") || name_lower.contains("vscode") { return "💻"; }
        if name_lower.contains("visual studio") { return "🟣"; }
        if name_lower.contains("sublime") { return "📝"; }
        if name_lower.contains("atom") { return "⚛️"; }
        if name_lower.contains("vim") || name_lower.contains("nvim") { return "📗"; }
        if name_lower.contains("notepad") { return "📄"; }
        if name_lower.contains("terminal") || name_lower.contains("cmd") || name_lower.contains("powershell") { return "⬛"; }
        if name_lower.contains("wt") { return "⬛"; }  // Windows Terminal
        
        // Office
        if name_lower.contains("word") { return "📘"; }
        if name_lower.contains("excel") { return "📊"; }
        if name_lower.contains("powerpoint") { return "📙"; }
        if name_lower.contains("outlook") { return "📧"; }
        if name_lower.contains("onenote") { return "📓"; }
        
        // Media
        if name_lower.contains("spotify") { return "🎵"; }
        if name_lower.contains("vlc") { return "🎬"; }
        if name_lower.contains("itunes") { return "🎶"; }
        if name_lower.contains("music") { return "🎵"; }
        if name_lower.contains("video") || name_lower.contains("player") { return "🎥"; }
        if name_lower.contains("photo") || name_lower.contains("image") { return "🖼️"; }
        
        // Communication
        if name_lower.contains("discord") { return "💬"; }
        if name_lower.contains("slack") { return "💼"; }
        if name_lower.contains("teams") { return "👥"; }
        if name_lower.contains("zoom") { return "📹"; }
        if name_lower.contains("skype") { return "📞"; }
        if name_lower.contains("telegram") { return "✈️"; }
        if name_lower.contains("whatsapp") { return "💚"; }
        
        // File management
        if name_lower.contains("explorer") { return "📁"; }
        if name_lower.contains("finder") { return "📂"; }
        if name_lower.contains("nautilus") { return "📂"; }
        
        // Games
        if name_lower.contains("steam") { return "🎮"; }
        if name_lower.contains("game") { return "🎮"; }
        if name_lower.contains("epic") { return "🎮"; }
        
        // System
        if name_lower.contains("settings") { return "⚙️"; }
        if name_lower.contains("control") { return "🎛️"; }
        if name_lower.contains("task") { return "📊"; }
        
        // Default
        "🪟"
    }

    fn show_live_view(&mut self, ctx: &egui::Context, ui: &mut egui::Ui) {
        let filter_lower = self.search_filter.to_lowercase();
        let mut window_to_focus: Option<u64> = None;

        // Filter windows first
        let filtered_windows: Vec<WindowInfo> = self.windows.iter()
            .filter(|window| {
                if filter_lower.is_empty() {
                    true
                } else {
                    let title_match = window.window_title.to_lowercase().contains(&filter_lower);
                    let process_match = window.process_name.to_lowercase().contains(&filter_lower);
                    let pid_match = window.pid.to_string().contains(&filter_lower);
                    title_match || process_match || pid_match
                }
            })
            .cloned()
            .collect();


        // Calculate layout geometry *before* capture so we know desired thumb size
        // We can use ui.available_size() but that might change if scrollbar appears? 
        // For Live View, we removed ScrollArea, so we use full available size.
        // BUT ui.available_size() inside show_live_view might be different than inside the panel logic below.
        // We'll estimate based on ctx.screen_rect() or just use a stored "last known size".
        // Better: Use a reliable estimate. Since we fit to window, let's grab the outer rect.
        let available_size = ui.available_size(); 
        // Note: available_size.x might be 0 if this is first frame or hidden.
        let safe_width = if available_size.x > 100.0 { available_size.x } else { 800.0 };
        let safe_height = if available_size.y > 100.0 { available_size.y } else { 600.0 };

        let num_cols = self.live_grid_size.max(1);
        let num_rows = self.live_grid_size.max(1);
        let spacing = 10.0;
        
        let cell_width = (safe_width - ((num_cols as f32 - 1.0) * spacing)) / num_cols as f32;
        let cell_height = (safe_height - ((num_rows as f32 - 1.0) * spacing)) / num_rows as f32;
        
        // Target thumb size is cell size scaled by detail percent
        let target_w = (cell_width * self.live_detail_percent).max(32.0);
        let target_h = (cell_height * self.live_detail_percent).max(32.0);

        // Update one thumbnail per interval (round-robin) - only when not paused
        if !self.live_paused && self.live_last_capture.elapsed() >= self.live_capture_interval && !filtered_windows.is_empty() {
            let window_idx = self.live_current_capture_index % filtered_windows.len();
            let window = &filtered_windows[window_idx];
            
            // Capture window thumbnail with desired size
            if let Some(image_data) = self.capture_window_thumbnail(window.window_id, target_w as i32, target_h as i32) {
                // Create or update texture
                let texture = ctx.load_texture(
                    format!("window_thumb_{}", window.window_id),
                    image_data,
                    egui::TextureOptions::default(),
                );
                self.live_thumbnails.insert(window.window_id, texture);
            }
            
            self.live_current_capture_index += 1;
            self.live_last_capture = Instant::now();
        }

        // Grid size determines items per page
        // Use squared for page size logic + generous buffer
        let items_per_page = (self.live_grid_size * self.live_grid_size).max(1); 
        let total_pages = (filtered_windows.len() + items_per_page - 1) / items_per_page;
        
        // Ensure current page is valid
        if self.live_page >= total_pages && total_pages > 0 {
            self.live_page = total_pages - 1;
        }

        let start_idx = self.live_page * items_per_page;
        let end_idx = (start_idx + items_per_page).min(filtered_windows.len());
        let page_windows = if start_idx < filtered_windows.len() {
            &filtered_windows[start_idx..end_idx]
        } else {
            &[]
        };

        // Header with pagination controls
        ui.horizontal(|ui| {
            ui.heading("📸 Live Preview - Real-time Window Thumbnails");
            ui.separator();
            
            // Stop/Resume button
            if self.live_paused {
                if ui.button("▶️ Resume").clicked() {
                    self.live_paused = false;
                }
                ui.colored_label(egui::Color32::YELLOW, "⏸ PAUSED");
            } else {
                if ui.button("⏹️ Stop").clicked() {
                    self.live_paused = true;
                }
            }
            
            ui.separator();
            
            if total_pages > 1 {
                if ui.button("◀ Prev").clicked() && self.live_page > 0 {
                    self.live_page -= 1;
                }
                ui.label(format!("Page {}/{}", self.live_page + 1, total_pages.max(1)));
                if ui.button("Next ▶").clicked() && self.live_page + 1 < total_pages {
                    self.live_page += 1;
                }
            }
            
            ui.label(format!(" | Showing {}-{} of {}", 
                start_idx + 1, 
                end_idx.min(filtered_windows.len()), 
                filtered_windows.len()
            ));
            
            ui.separator();
            
            // Interval control
            ui.label("Update speed:");
            if ui.button("🐢 Slow").clicked() {
                self.live_capture_interval = Duration::from_millis(500);
            }
            if ui.button("🐇 Fast").clicked() {
                self.live_capture_interval = Duration::from_millis(100);
            }
        });

        ui.separator();

        // Grid view with 5x4 layout
        // Grid view with fit-to-window layout (No Scroll)
        // Calculate available space for grid
        let spacing = 10.0;
        let available_size = ui.available_size();
        let num_cols = self.live_grid_size.max(1);
        let num_rows = self.live_grid_size.max(1); // Keep it square grid logic for now, or could depend on aspect ratio. User asked for 3x3, 4x4 so rows=cols.
        
        let thumb_width = (available_size.x - ((num_cols as f32 - 1.0) * spacing)) / num_cols as f32;
        // Subtract a bit for text/margin below thumb.
        let cell_height = (available_size.y - ((num_rows as f32 - 1.0) * spacing)) / num_rows as f32;
        // Reserve space for text (e.g. 30px) inside the cell height logic if fixed,
        // or just let thumb be height - text_height.
        let thumb_height = (cell_height - 30.0).max(10.0);
        
        // Remove ScrollArea, just draw.
        // Also note: we already paginated with items_per_page = grid_size^2, so we just show 'page_windows'.
        
        for row_windows in page_windows.chunks(num_cols) {
                    ui.horizontal(|ui| {
                        ui.spacing_mut().item_spacing = egui::vec2(spacing, spacing);
                        
                        for window in row_windows {
                            let is_foreground = window.is_foreground;
                            let bg_color = if is_foreground {
                                egui::Color32::from_rgb(60, 120, 180)
                            } else {
                                egui::Color32::from_rgb(35, 35, 40)
                            };
                            
                            let border_color = if is_foreground {
                                egui::Color32::from_rgb(100, 180, 255)
                            } else {
                                egui::Color32::from_rgb(70, 70, 80)
                            };

                            // Create a frame for each thumbnail
                            egui::Frame::none()
                                .fill(bg_color)
                                .stroke(egui::Stroke::new(2.0, border_color))
                                .rounding(6.0)
                                .inner_margin(4.0)
                                .show(ui, |ui| {
                                    ui.set_min_size(egui::vec2(thumb_width, thumb_height + 30.0));
                                    ui.set_max_size(egui::vec2(thumb_width, thumb_height + 30.0));

                                    ui.vertical(|ui| {
                                        // Thumbnail area
                                        let (rect, response) = ui.allocate_exact_size(
                                            egui::vec2(thumb_width - 8.0, thumb_height),
                                            egui::Sense::click(),
                                        );
                                        
                                        // Draw thumbnail or placeholder
                                        if let Some(texture) = self.live_thumbnails.get(&window.window_id) {
                                            ui.painter().image(
                                                texture.id(),
                                                rect,
                                                egui::Rect::from_min_max(egui::pos2(0.0, 0.0), egui::pos2(1.0, 1.0)),
                                                egui::Color32::WHITE,
                                            );
                                        } else {
                                            // Placeholder with icon
                                            ui.painter().rect_filled(rect, 4.0, egui::Color32::from_rgb(50, 50, 55));
                                            let icon = Self::get_process_icon(&window.process_name);
                                            ui.painter().text(
                                                rect.center(),
                                                egui::Align2::CENTER_CENTER,
                                                icon,
                                                egui::FontId::proportional(32.0),
                                                egui::Color32::from_gray(150),
                                            );
                                        }

                                        if response.clicked() {
                                            window_to_focus = Some(window.window_id);
                                        }

                                        // Show tooltip on hover
                                        if response.hovered() {
                                            egui::show_tooltip(ui.ctx(), ui.layer_id(), egui::Id::new(window.window_id), |ui| {
                                                ui.label(format!("📋 {}", window.window_title));
                                                ui.label(format!("🖥 {}", window.process_name));
                                                ui.label(format!("PID: {}", window.pid));
                                                if window.is_foreground {
                                                    ui.colored_label(egui::Color32::from_rgb(100, 200, 255), "🔷 Active");
                                                }
                                            });
                                        }

                                        // Title below thumbnail
                                        let title_display = if window.window_title.len() > 22 {
                                            format!("{}...", &window.window_title.chars().take(19).collect::<String>())
                                        } else {
                                            window.window_title.clone()
                                        };
                                        
                                        let title_response = ui.add(
                                            egui::Label::new(
                                                egui::RichText::new(&title_display)
                                                    .size(10.0)
                                                    .color(egui::Color32::WHITE)
                                            )
                                            .sense(egui::Sense::click())
                                        );
                                        
                                        if title_response.clicked() {
                                            window_to_focus = Some(window.window_id);
                                        }
                                    });
                                });
                        }
                    });
                    
                    ui.add_space(spacing);
                }

                // Bring window to foreground if clicked
                if let Some(window_id) = window_to_focus {
                    self.bring_window_to_foreground(window_id);
                    self.add_log(format!("Switched to window ID: {}", window_id));
                }
        
        // Request repaint to keep updating if not paused
        if !self.live_paused {
            ctx.request_repaint();
        }
    }

    #[cfg(windows)]
    fn capture_window_thumbnail(&self, window_id: u64, max_width: i32, max_height: i32) -> Option<egui::ColorImage> {
        use windows::Win32::Foundation::HWND;
        use windows::Win32::Graphics::Gdi::{
            CreateCompatibleDC, CreateCompatibleBitmap, SelectObject, DeleteDC, DeleteObject,
            GetDC, ReleaseDC, BitBlt, SRCCOPY, GetDIBits, BITMAPINFO, BITMAPINFOHEADER,
            BI_RGB, DIB_RGB_COLORS,
        };
        use windows::Win32::UI::WindowsAndMessaging::GetWindowRect;
        
        unsafe {
            let hwnd = HWND(window_id as *mut _);
            
            // Get window size
            let mut rect = std::mem::zeroed();
            if GetWindowRect(hwnd, &mut rect).is_err() {
                return None;
            }
            
            let width = (rect.right - rect.left) as i32;
            let height = (rect.bottom - rect.top) as i32;
            
            if width <= 0 || height <= 0 {
                return None;
            }
            
            // Scale down for thumbnail
            let max_width = max_width.max(32) as f32;
            let max_height = max_height.max(32) as f32;
            let scale = f32::min(max_width / width as f32, max_height / height as f32).min(1.0);
            let thumb_width = (width as f32 * scale) as i32;
            let thumb_height = (height as f32 * scale) as i32;
            
            if thumb_width <= 0 || thumb_height <= 0 {
                return None;
            }
            
            // Create DC and bitmap
            let hdc_window = GetDC(hwnd);
            if hdc_window.0.is_null() {
                return None;
            }
            
            let hdc_mem = CreateCompatibleDC(hdc_window);
            if hdc_mem.0.is_null() {
                ReleaseDC(hwnd, hdc_window);
                return None;
            }
            
            let hbitmap = CreateCompatibleBitmap(hdc_window, width, height);
            if hbitmap.0.is_null() {
                DeleteDC(hdc_mem);
                ReleaseDC(hwnd, hdc_window);
                return None;
            }
            
            let old_bitmap = SelectObject(hdc_mem, hbitmap);
            
            // Capture window content using BitBlt
            let _ = BitBlt(hdc_mem, 0, 0, width, height, hdc_window, 0, 0, SRCCOPY);
            
            // Get bitmap data
            let mut bmi = BITMAPINFO {
                bmiHeader: BITMAPINFOHEADER {
                    biSize: std::mem::size_of::<BITMAPINFOHEADER>() as u32,
                    biWidth: width,
                    biHeight: -height, // Top-down
                    biPlanes: 1,
                    biBitCount: 32,
                    biCompression: BI_RGB.0,
                    biSizeImage: 0,
                    biXPelsPerMeter: 0,
                    biYPelsPerMeter: 0,
                    biClrUsed: 0,
                    biClrImportant: 0,
                },
                bmiColors: [std::mem::zeroed()],
            };
            
            let mut buffer: Vec<u8> = vec![0; (width * height * 4) as usize];
            
            let result = GetDIBits(
                hdc_mem,
                hbitmap,
                0,
                height as u32,
                Some(buffer.as_mut_ptr() as *mut _),
                &mut bmi,
                DIB_RGB_COLORS,
            );
            
            // Cleanup
            SelectObject(hdc_mem, old_bitmap);
            DeleteObject(hbitmap);
            DeleteDC(hdc_mem);
            ReleaseDC(hwnd, hdc_window);
            
            if result == 0 {
                return None;
            }
            
            // Convert BGRA to RGBA and resize
            let mut pixels = Vec::with_capacity((thumb_width * thumb_height) as usize);
            
            for y in 0..thumb_height {
                for x in 0..thumb_width {
                    // Simple nearest-neighbor scaling
                    let src_x = (x as f32 / scale) as i32;
                    let src_y = (y as f32 / scale) as i32;
                    let src_idx = ((src_y * width + src_x) * 4) as usize;
                    
                    if src_idx + 3 < buffer.len() {
                        let b = buffer[src_idx];
                        let g = buffer[src_idx + 1];
                        let r = buffer[src_idx + 2];
                        pixels.push(egui::Color32::from_rgb(r, g, b));
                    } else {
                        pixels.push(egui::Color32::from_gray(50));
                    }
                }
            }
            
            Some(egui::ColorImage {
                size: [thumb_width as usize, thumb_height as usize],
                pixels,
            })
        }
    }

    #[cfg(not(windows))]
    fn capture_window_thumbnail(&self, _window_id: u64, _max_width: i32, _max_height: i32) -> Option<egui::ColorImage> {
        // Placeholder for non-Windows platforms
        None
    }

    fn show_new_program_launcher(&mut self, ui: &mut egui::Ui) {
        egui::ScrollArea::vertical()
            .auto_shrink([false, false])
            .show(ui, |ui| {
                ui.heading("🚀 Launch New Program");
                ui.add_space(20.0);

                // Program path input
                ui.horizontal(|ui| {
                    ui.label("Program Path:");
                    ui.add(egui::TextEdit::singleline(&mut self.program_path)
                        .desired_width(350.0)
                        .hint_text("e.g., C:\\Windows\\System32\\notepad.exe or /usr/bin/gedit"));

                    if ui.button("📂 Browse...").clicked() {
                        if let Some(path) = self.browse_for_program() {
                            self.program_path = path;
                        }
                    }
                });

                ui.add_space(10.0);

                // Arguments input
                ui.horizontal(|ui| {
                    ui.label("Arguments:      ");
                    ui.add(egui::TextEdit::singleline(&mut self.program_args)
                        .desired_width(400.0)
                        .hint_text("Optional arguments (e.g., --help or file.txt)"));
                });

                ui.add_space(10.0);

                // Run as administrator checkbox (Windows only)
                #[cfg(windows)]
                ui.checkbox(&mut self.run_as_admin, "⚡ Run as Administrator");

                ui.add_space(20.0);

                // Launch button
                ui.horizontal(|ui| {
                    if ui.button("▶ Launch Program").clicked() {
                        if !self.program_path.is_empty() {
                            // Clone the values to avoid borrow checker issues
                            let program_path = self.program_path.clone();
                            let program_args = self.program_args.clone();
                            let run_as_admin = self.run_as_admin;

                            match self.launch_program(&program_path, &program_args, run_as_admin) {
                                Ok(pid) => {
                                    if pid > 0 {
                                        ui.label(format!("✓ Program launched successfully! PID: {}", pid));
                                    } else {
                                        ui.label("✓ Program launched with elevation (PID unavailable)");
                                    }
                                    // Clear inputs after successful launch
                                    self.program_path.clear();
                                    self.program_args.clear();
                                    // Refresh to show new process
                                    self.refresh_all_data();
                                }
                                Err(e) => {
                                    ui.colored_label(egui::Color32::RED, format!("✗ Failed to launch: {}", e));
                                }
                            }
                        }
                    }

                    if ui.button("🗑 Clear").clicked() {
                        self.program_path.clear();
                        self.program_args.clear();
                    }
                });

                ui.add_space(30.0);
                ui.separator();
                ui.add_space(10.0);

                // Common programs section
                ui.heading("Quick Launch");
                ui.add_space(10.0);

                ui.label("Common Programs:");
                ui.add_space(5.0);

                // Platform-specific common programs
                #[cfg(windows)]
                {
                    ui.horizontal_wrapped(|ui| {
                        if ui.button("📝 Notepad").clicked() {
                            let _ = self.launch_program("C:\\Windows\\System32\\notepad.exe", "", false);
                            self.refresh_all_data();
                        }
                        if ui.button("💻 CMD").clicked() {
                            let _ = self.launch_program("C:\\Windows\\System32\\cmd.exe", "", false);
                            self.refresh_all_data();
                        }
                        if ui.button("⚡ CMD (Admin)").clicked() {
                            let _ = self.launch_program("C:\\Windows\\System32\\cmd.exe", "", true);
                            self.refresh_all_data();
                        }
                        if ui.button("🔧 PowerShell").clicked() {
                            let _ = self.launch_program("C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe", "", false);
                            self.refresh_all_data();
                        }
                        if ui.button("⚡ PowerShell (Admin)").clicked() {
                            let _ = self.launch_program("C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe", "", true);
                            self.refresh_all_data();
                        }
                        if ui.button("📁 Explorer").clicked() {
                            let _ = self.launch_program("C:\\Windows\\explorer.exe", "", false);
                            self.refresh_all_data();
                        }
                        if ui.button("⚙️ Task Manager").clicked() {
                            let _ = self.launch_program("C:\\Windows\\System32\\taskmgr.exe", "", false);
                            self.refresh_all_data();
                        }
                        if ui.button("🖩 Calculator").clicked() {
                            let _ = self.launch_program("C:\\Windows\\System32\\calc.exe", "", false);
                            self.refresh_all_data();
                        }
                    });

                    ui.add_space(10.0);
                    ui.label("System Configuration:");
                    ui.add_space(5.0);

                    ui.horizontal_wrapped(|ui| {
                        if ui.button("🌐 Network Config").clicked() {
                            let _ = self.launch_program("control.exe", "ncpa.cpl", false);
                        }
                        if ui.button("💻 System Properties").clicked() {
                            let _ = self.launch_program("control.exe", "sysdm.cpl", false);
                        }
                        if ui.button("📦 Programs & Features").clicked() {
                            let _ = self.launch_program("control.exe", "appwiz.cpl", false);
                        }
                        if ui.button("🔌 Device Manager").clicked() {
                            let _ = self.launch_program("mmc.exe", "devmgmt.msc", false);
                        }
                        if ui.button("💾 Disk Management").clicked() {
                            let _ = self.launch_program("mmc.exe", "diskmgmt.msc", false);
                        }
                        if ui.button("⚙️ Services").clicked() {
                            let _ = self.launch_program("mmc.exe", "services.msc", false);
                        }
                        if ui.button("📝 Registry Editor").clicked() {
                            let _ = self.launch_program("regedit.exe", "", true);
                        }
                        if ui.button("🎛️ Control Panel").clicked() {
                            let _ = self.launch_program("control.exe", "", false);
                        }
                        if ui.button("🛡️ Firewall").clicked() {
                            let _ = self.launch_program("control.exe", "firewall.cpl", false);
                        }
                    });
                }

                #[cfg(target_os = "linux")]
                {
                    ui.horizontal_wrapped(|ui| {
                        if ui.button("📝 Text Editor (gedit)").clicked() {
                            let _ = self.launch_program("/usr/bin/gedit", "", false);
                            self.refresh_all_data();
                        }
                        if ui.button("💻 Terminal").clicked() {
                            let _ = self.launch_program("/usr/bin/gnome-terminal", "", false);
                            self.refresh_all_data();
                        }
                        if ui.button("📁 Files").clicked() {
                            let _ = self.launch_program("/usr/bin/nautilus", "", false);
                            self.refresh_all_data();
                        }
                        if ui.button("🌐 Firefox").clicked() {
                            let _ = self.launch_program("/usr/bin/firefox", "", false);
                            self.refresh_all_data();
                        }
                        if ui.button("🖩 Calculator").clicked() {
                            let _ = self.launch_program("/usr/bin/gnome-calculator", "", false);
                            self.refresh_all_data();
                        }
                    });
                }

                #[cfg(target_os = "macos")]
                {
                    ui.horizontal_wrapped(|ui| {
                        if ui.button("📝 TextEdit").clicked() {
                            let _ = self.launch_program("/Applications/TextEdit.app/Contents/MacOS/TextEdit", "", false);
                            self.refresh_all_data();
                        }
                        if ui.button("💻 Terminal").clicked() {
                            let _ = self.launch_program("/Applications/Utilities/Terminal.app/Contents/MacOS/Terminal", "", false);
                            self.refresh_all_data();
                        }
                        if ui.button("📁 Finder").clicked() {
                            let _ = self.launch_program("/System/Library/CoreServices/Finder.app/Contents/MacOS/Finder", "", false);
                            self.refresh_all_data();
                        }
                    });
                }

                ui.add_space(20.0);
                ui.separator();
                ui.add_space(10.0);

                // Instructions
                ui.heading("ℹ️ Instructions");
                ui.add_space(5.0);
                ui.label("• Enter the full path to the executable you want to launch");
                ui.label("• Add any command-line arguments in the Arguments field (optional)");
                ui.label("• Click 'Launch Program' to start the process");
                ui.label("• The new process will appear in the Processes tab");
                ui.add_space(10.0);
                ui.label("💡 Tip: Use the Quick Launch buttons for common programs");

                if !self.custom_programs.is_empty() {
                    ui.add_space(20.0);
                    ui.separator();
                    ui.add_space(10.0);
                    ui.heading("⭐ Custom Programs");
                    ui.add_space(10.0);

                    ui.horizontal_wrapped(|ui| {
                        let programs = self.custom_programs.clone();
                        for program in programs {
                            if ui.button(format!("🚀 {}", program.name)).on_hover_text(&program.path).clicked() {
                                let _ = self.launch_program(&program.path, &program.args, program.admin);
                                self.refresh_all_data();
                            }
                        }
                    });
                }
            });
    }

    fn show_font_picker(&mut self, ctx: &egui::Context) {
        let mut open = self.font_picker.is_open;
        egui::Window::new("🔤 Select Font")
            .open(&mut open)
            .resize(|r| r.fixed_size([600.0, 500.0]))
            .min_width(500.0)
            .min_height(400.0)
            .show(ctx, |ui| {
                ui.heading("Browse Fonts");
                ui.add_space(5.0);

                // Directory Selection
                ui.horizontal(|ui| {
                    ui.label("Directory:");
                    let response = ui.add(egui::TextEdit::singleline(&mut self.font_picker.directory).desired_width(300.0));
                    if ui.button("📂 Scan").clicked() || (response.lost_focus() && response.ctx.input(|i| i.key_pressed(egui::Key::Enter))) {
                        // Scan directory
                        let path = std::path::Path::new(&self.font_picker.directory);
                        if path.exists() && path.is_dir() {
                            self.font_picker.files.clear();
                            self.font_picker.error_msg = None;
                            if let Ok(entries) = std::fs::read_dir(path) {
                                for entry in entries.flatten() {
                                    if let Ok(file_type) = entry.file_type() {
                                        if file_type.is_file() {
                                            if let Some(name) = entry.file_name().to_str() {
                                                let lower = name.to_lowercase();
                                                if lower.ends_with(".ttf") || lower.ends_with(".ttc") || lower.ends_with(".otf") {
                                                    self.font_picker.files.push(name.to_string());
                                                }
                                            }
                                        }
                                    }
                                }
                                self.font_picker.files.sort();
                            }
                        } else {
                            self.font_picker.error_msg = Some("Directory does not exist".to_string());
                        }
                    }
                });

                if let Some(err) = &self.font_picker.error_msg {
                    ui.colored_label(egui::Color32::RED, err);
                }

                ui.add_space(5.0);
                
                // Filter
                ui.horizontal(|ui| {
                    ui.label("Filter:");
                    ui.text_edit_singleline(&mut self.font_picker.filter);
                });

                ui.separator();

                // Split view: List | Preview
                ui.columns(2, |columns| {
                    // List
                    columns[0].vertical(|ui| {
                        ui.label("Files:");
                        egui::ScrollArea::vertical().max_height(300.0).show(ui, |ui| {
                            let filter = self.font_picker.filter.to_lowercase();
                            // Use indices to avoid borrow checker issues with filtered iterator
                            let files = self.font_picker.files.clone();
                            for file in files {
                                if !filter.is_empty() && !file.to_lowercase().contains(&filter) {
                                    continue;
                                }

                                let is_selected = self.font_picker.selected_file.as_ref() == Some(&file);
                                if ui.selectable_label(is_selected, &file).clicked() {
                                    self.font_picker.selected_file = Some(file.clone());
                                    // Trigger preview load
                                    self.configure_fonts(ui.ctx(), true);
                                }
                            }
                        });
                    });

                    // Preview
                    columns[1].vertical(|ui| {
                        ui.label("Preview:");
                        
                        let preview_family = egui::FontFamily::Name("Preview".into());
                        let has_preview = ctx.fonts(|f| f.families().contains(&preview_family));
                        
                        ui.add(
                            egui::TextEdit::multiline(&mut self.font_picker.preview_text)
                                .font(egui::FontId::new(24.0, if has_preview { preview_family } else { egui::FontFamily::Proportional }))
                                .desired_width(f32::INFINITY)
                                .desired_rows(8)
                        );
                        
                        ui.add_space(10.0);
                        if let Some(selected) = &self.font_picker.selected_file {
                            ui.label(format!("Selected: {}", selected));
                            ui.add_space(5.0);
                            if ui.button("✅ Apply Font").clicked() {
                                // Construct full path
                                let path = std::path::Path::new(&self.font_picker.directory).join(selected);
                                self.font_path = path.to_string_lossy().to_string();
                                self.save_config();
                                self.configure_fonts(ui.ctx(), false); // Apply globally
                                self.font_picker.is_open = false;
                            }
                        } else {
                            ui.label("Select a font to preview");
                        }
                    });
                });
            });
        
        self.font_picker.is_open = open;
    }

    fn show_settings_view(&mut self, ui: &mut egui::Ui) {
        egui::ScrollArea::vertical()
            .auto_shrink([false, false])
            .show(ui, |ui| {
                ui.heading("⚙️ Application Settings");
                ui.add_space(20.0);

                ui.group(|ui| {
                    ui.heading("Configuration Data");
                    ui.add_space(5.0);
                    let config_path = Self::get_config_path();
                    ui.label(format!("Path: {}", config_path.display()));
                    
                    if ui.button("📂 Open Config Directory").clicked() {
                        if let Some(parent) = config_path.parent() {
                            #[cfg(target_os = "windows")]
                            let _ = std::process::Command::new("explorer").arg(parent).spawn();
                            #[cfg(target_os = "linux")]
                            let _ = std::process::Command::new("xdg-open").arg(parent).spawn();
                            #[cfg(target_os = "macos")]
                            let _ = std::process::Command::new("open").arg(parent).spawn();
                            
                            self.add_log("Opened configuration directory".to_string());
                        }
                    }
                });
                ui.add_space(20.0);

                ui.group(|ui| {
                    ui.heading("Appearance");
                    ui.add_space(10.0);
                    
                    // Font settings
                    ui.label("Font Configuration:");
                    
                    let fonts = vec![
                        ("Default", ""),
                        ("Microsoft JhengHei (微軟正黑體)", "C:\\Windows\\Fonts\\msjh.ttc"),
                        ("PMingLiU (新細明體)", "C:\\Windows\\Fonts\\mingliu.ttc"),
                    ];

                    let current_font_name = fonts.iter()
                        .find(|(_, path)| *path == self.font_path)
                        .map(|(name, _)| *name)
                        .unwrap_or("Custom / Unknown");

                    egui::ComboBox::from_label("Select Font")
                        .selected_text(current_font_name)
                        .show_ui(ui, |ui| {
                            for (name, path) in fonts {
                                if ui.selectable_value(&mut self.font_path, path.to_string(), name).clicked() {
                                    self.save_config();
                                    self.configure_fonts(ui.ctx(), false);
                                }
                            }
                        });

                    if ui.button("📂 Browse System Fonts...").clicked() {
                         self.font_picker.is_open = true;
                         // Auto-scan if empty
                         if self.font_picker.files.is_empty() {
                             // trigger scan logic manually or wait for user
                             // We'll duplicate the scan logic slightly or just let them click Scan.
                             // Actually, let's pre-scan to be nice
                            let path = std::path::Path::new(&self.font_picker.directory);
                            if path.exists() && path.is_dir() {
                                self.font_picker.files.clear();
                                if let Ok(entries) = std::fs::read_dir(path) {
                                    for entry in entries.flatten() {
                                        if let Ok(file_type) = entry.file_type() {
                                            if file_type.is_file() {
                                                if let Some(name) = entry.file_name().to_str() {
                                                    let lower = name.to_lowercase();
                                                    if lower.ends_with(".ttf") || lower.ends_with(".ttc") || lower.ends_with(".otf") {
                                                        self.font_picker.files.push(name.to_string());
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    self.font_picker.files.sort();
                                }
                            }
                         }
                    }

                    if ui.checkbox(&mut self.use_noto_font, "Use Noto Font (Legacy Option)").clicked() {
                        self.save_config();
                    }
                    ui.label(egui::RichText::new("Example text: 你好, 世界! Hello World! 🌍").size(14.0));
                    
                    ui.add_space(10.0);
                    ui.separator();
                    ui.add_space(10.0);
                    
                    // Theme settings
                    ui.label("Theme:");
                    ui.horizontal(|ui| {
                        if ui.selectable_label(self.theme == Theme::Dark, "🌙 Dark").clicked() {
                            self.theme = Theme::Dark;
                            self.save_config();
                        }
                        if ui.selectable_label(self.theme == Theme::Light, "☀️ Light").clicked() {
                            self.theme = Theme::Light;
                            self.save_config();
                        }
                    });
                });
                
                ui.add_space(20.0);
                
                ui.group(|ui| {
                    ui.heading("Behavior");
                    ui.add_space(10.0);
                    
                    ui.checkbox(&mut self.show_window_grid, "Show window grid in Windows view");
                    
                    ui.add_space(5.0);
                    ui.label("Live View Grid Size:");
                    ui.horizontal(|ui| {
                        let sizes = [2, 3, 4, 5, 6, 8];
                        for size in sizes {
                            if ui.selectable_label(self.live_grid_size == size, format!("{}x{}", size, size)).clicked() {
                                self.live_grid_size = size;
                                self.save_config();
                            }
                        }
                    });
                    
                    ui.add_space(5.0);
                    ui.label("Live View Detail (%):");
                    ui.horizontal(|ui| {
                        let percents = [25, 50, 75, 100];
                        for p in percents {
                            let val = p as f32 / 100.0;
                            if ui.selectable_label((self.live_detail_percent - val).abs() < 0.01, format!("{}%", p)).clicked() {
                                self.live_detail_percent = val;
                                self.save_config();
                            }
                        }
                    });

                    ui.add_space(10.0);
                    ui.separator();
                    ui.add_space(10.0);

                    // Admin startup settings
                    ui.label("Administrator Privileges:");

                    ui.horizontal(|ui| {
                        if ui.checkbox(&mut self.attempt_start_as_admin, "Start WinShell as Administrator").on_hover_text(
                            "When enabled, WinShell will attempt to restart with administrator privileges on startup\n\
                            This provides full system access but requires UAC confirmation"
                        ).clicked() {
                            self.save_config();
                        }

                        // Show current admin status
                        let is_admin = ProcessManagerApp::is_user_admin();
                        let status_color = if is_admin {
                            egui::Color32::from_rgb(100, 200, 100)
                        } else {
                            egui::Color32::from_rgb(200, 100, 100)
                        };
                        let status_text = if is_admin { "✓ Running as Admin" } else { "○ Standard User" };
                        ui.label(egui::RichText::new(status_text).color(status_color).size(14.0));
                    });

                    #[cfg(windows)]
                    ui.checkbox(&mut self.run_as_admin, "Default to 'Run as Administrator' for new programs");
                });
            });
    }

    fn show_filepane_view(&mut self, ui: &mut egui::Ui) {
        // Ensure we have at least one tab
        if self.filepane_tabs.is_empty() {
            self.filepane_tabs.push(FilepaneTab::new(
                "Tab 1".to_string(),
                std::env::current_dir().unwrap_or_else(|_| std::path::PathBuf::from("C:\\")).to_string_lossy().to_string(),
                std::env::current_dir().unwrap_or_else(|_| std::path::PathBuf::from("C:\\")).to_string_lossy().to_string(),
            ));
            self.filepane_active_tab = 0;
        }

        // Header with tab controls and filter
        ui.horizontal(|ui| {
            ui.heading("📂 Filepane");

            ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
                ui.label("Filter:");
                ui.add_sized(
                    [200.0, 20.0],
                    egui::TextEdit::singleline(&mut self.filepane_tabs[self.filepane_active_tab].filter)
                        .hint_text("type to filter...")
                );

                ui.separator();

                // Operations group
                if ui.button("↔️ Swap").on_hover_text("Swap left and right columns").clicked() {
                    self.filepane_swap_columns = !self.filepane_swap_columns;
                }

                if ui.button("☑️ Checkboxes").on_hover_text("Toggle selection checkboxes").clicked() {
                    let tab = &mut self.filepane_tabs[self.filepane_active_tab];
                    tab.show_checkboxes = !tab.show_checkboxes;
                    if !tab.show_checkboxes {
                        tab.left_checkboxes.clear();
                        tab.right_checkboxes.clear();
                    }
                }

                ui.separator();

                // Tab management group
                if ui.button("⏭ Copy→→").on_hover_text("Copy selected files from current to opposite panel").clicked() {
                    self.copy_files_to_opposite_panel();
                }

                if ui.button("⊞ Duplicate").on_hover_text("Duplicate current tab").clicked() {
                    self.duplicate_current_tab();
                }

                ui.separator();

                // History group
                if ui.button("↶ Undo").on_hover_text("Undo last action").clicked() {
                    self.undo_last_action();
                }
                if ui.button("↷ Redo").on_hover_text("Redo undone action").clicked() {
                    self.redo_last_action();
                }

                ui.separator();

                // Configuration group
                if ui.button("💾 Save").on_hover_text("Save current paths to config").clicked() {
                    self.save_current_paths();
                }

                if ui.button("📁 Save All").on_hover_text("Save all tabs to config").clicked() {
                    self.save_all_tabs();
                }

                if ui.button("📂 Load").on_hover_text("Load paths from config").clicked() {
                    self.load_paths_from_config();
                }

                ui.separator();

                // Tab creation
                if ui.button("+").on_hover_text("Add new tab").clicked() {
                    let tab_count = self.filepane_tabs.len() + 1;
                    self.filepane_tabs.push(FilepaneTab::new(
                        format!("Tab {}", tab_count),
                        self.filepane_tabs[self.filepane_active_tab].left_path.clone(),
                        self.filepane_tabs[self.filepane_active_tab].right_path.clone(),
                    ));
                    self.filepane_active_tab = self.filepane_tabs.len() - 1;
                }
            });
        });

        // Tab bar
        ui.horizontal(|ui| {
            let mut tab_to_close = None;

            for (i, tab) in self.filepane_tabs.iter_mut().enumerate() {
                let is_active = i == self.filepane_active_tab;

                let tab_button = ui.selectable_label(
                    is_active,
                    format!("{} {}{}{}",
                        if is_active { "🔵" } else { "⚪" },
                        tab.name,
                        if !tab.left_checkboxes.is_empty() || !tab.right_checkboxes.is_empty() { " ☑️" } else { "" },
                        if !tab.selected_left.is_empty() || !tab.selected_right.is_empty() { " ✓" } else { "" }
                    )
                );

                if tab_button.clicked() {
                    self.filepane_active_tab = i;
                }

                if ui.button("❌").on_hover_text(&format!("Close {}", tab.name)).clicked() {
                    tab_to_close = Some(i);
                }

                ui.add_space(5.0);
            }

            // Close tab if requested
            if let Some(index) = tab_to_close {
                if self.filepane_tabs.len() > 1 {
                    self.filepane_tabs.remove(index);
                    if self.filepane_active_tab >= self.filepane_tabs.len() {
                        self.filepane_active_tab = self.filepane_tabs.len() - 1;
                    }
                }
            }
        });

        ui.separator();

        // Get current tab data
        let current_tab = &mut self.filepane_tabs[self.filepane_active_tab];
        let left_path = current_tab.left_path.clone();
        let right_path = current_tab.right_path.clone();
        let show_hidden = self.show_window_grid;

        // Calculate available space for panels
        let available_height = ui.available_height() - 120.0; // Reserve space for operations and settings

        // Two-column layout with potential swapping
        ui.horizontal(|ui| {
            let (first_panel_path, second_panel_path) = if self.filepane_swap_columns {
                (&right_path, &left_path)
            } else {
                (&left_path, &right_path)
            };

            let first_panel_index = if self.filepane_swap_columns { 1 } else { 0 };
            let second_panel_index = if self.filepane_swap_columns { 0 } else { 1 };

            // First panel (left or right based on swap state)
            ui.allocate_ui_with_layout(
                egui::vec2(ui.available_width() * 0.5, available_height),
                egui::Layout::top_down(egui::Align::LEFT),
                |ui| {
                    self.show_file_panel_header_with_checkboxes(ui, first_panel_index);
                    ui.add_space(2.0);
                    self.show_file_panel_with_checkboxes(ui, first_panel_path, first_panel_index);
                }
            );

            ui.separator();

            // Second panel (right or left based on swap state)
            ui.allocate_ui_with_layout(
                egui::vec2(ui.available_width(), available_height),
                egui::Layout::top_down(egui::Align::LEFT),
                |ui| {
                    self.show_file_panel_header_with_checkboxes(ui, second_panel_index);
                    ui.add_space(2.0);
                    self.show_file_panel_with_checkboxes(ui, second_panel_path, second_panel_index);
                }
            );
        });

        // Show context menu if triggered
        let mut context_actions = Vec::new();
        if self.show_context_menu {
            if let Some((ref file_info, panel_index)) = self.context_menu_file.take() {
                // Clone the data we need to avoid borrowing issues
                let file_info_clone = file_info.clone();
                let file_path = file_info_clone.path.clone();
                let file_name = file_info_clone.name.clone();
                let is_directory = file_info_clone.is_directory;

                // Get current tab info for operations
                let (tab_index, dest_path, speed_limit) = {
                    let tab = &self.filepane_tabs[self.filepane_active_tab];
                    (
                        self.filepane_active_tab,
                        if panel_index == 0 { tab.right_path.clone() } else { tab.left_path.clone() },
                        tab.copy_speed_limit_mb_per_sec
                    )
                };

                egui::Area::new(egui::Id::new("context_menu"))
                    .fixed_pos(ui.input(|i| i.pointer.hover_pos()).unwrap_or_default())
                    .show(ui.ctx(), |ui| {
                        egui::Frame::popup(ui.style())
                            .inner_margin(4.0)
                            .show(ui, |ui| {
                                ui.set_min_width(200.0);

                                // Show file/directory name as header
                                ui.label(egui::RichText::new(&file_name).strong());
                                ui.separator();

                                // Open/Enter Directory
                                if is_directory {
                                    if ui.button("📂 Open").clicked() {
                                        context_actions.push(ContextAction::NavigateToDirectory {
                                            path: file_path.clone(),
                                            panel_index
                                        });
                                    }
                                } else {
                                    // For files, show Open option
                                    if ui.button("🔧 Open").clicked() {
                                        context_actions.push(ContextAction::OpenFile {
                                            path: file_path.clone()
                                        });
                                    }
                                }

                                ui.separator();

                                // Copy operations
                                if ui.button("📋 Copy").clicked() {
                                    context_actions.push(ContextAction::CopyFile {
                                        source: file_path.clone(),
                                        destination: dest_path.clone(),
                                        speed_limit
                                    });
                                }

                                if ui.button("✂️ Cut").clicked() {
                                    context_actions.push(ContextAction::Cut);
                                }

                                ui.separator();

                                // File operations
                                if ui.button("🏷️ Rename").clicked() {
                                    context_actions.push(ContextAction::LogMessage(format!("Rename not implemented for: {}", file_name)));
                                }

                                if ui.button("🗑️ Delete").clicked() {
                                    context_actions.push(ContextAction::LogMessage(format!("Delete not implemented for: {}", file_name)));
                                }

                                ui.separator();

                                // Utilities
                                if ui.button("🔐 Checksum").clicked() {
                                    context_actions.push(ContextAction::LogMessage(format!("Calculating checksum for: {}", file_name)));
                                }

                                if ui.button("📋 Copy Path").clicked() {
                                    ui.output_mut(|o| o.copied_text = file_path.clone());
                                    context_actions.push(ContextAction::CloseMenu);
                                }

                                if ui.button("ℹ️ Properties").clicked() {
                                    context_actions.push(ContextAction::ShowProperties { file_info: file_info_clone });
                                }
                            });
                    });

                // Execute actions after UI is done to avoid borrowing conflicts
                for action in context_actions.drain(..) {
                    match action {
                        ContextAction::NavigateToDirectory { path, panel_index } => {
                            if panel_index == 0 {
                                self.filepane_tabs[tab_index].left_path = path;
                                self.filepane_tabs[tab_index].selected_left.clear();
                                self.filepane_tabs[tab_index].left_checkboxes.clear();
                            } else {
                                self.filepane_tabs[tab_index].right_path = path;
                                self.filepane_tabs[tab_index].selected_right.clear();
                                self.filepane_tabs[tab_index].right_checkboxes.clear();
                            }
                        }
                        ContextAction::OpenFile { path } => {
                            self.open_file_with_system(&path);
                        }
                        ContextAction::CopyFile { source, destination, speed_limit } => {
                            self.copy_files_with_limit(vec![source], &destination, speed_limit);
                        }
                        ContextAction::Cut => {
                            self.cut_selected_files();
                        }
                        ContextAction::ShowProperties { file_info } => {
                            self.show_file_properties(&file_info);
                        }
                        ContextAction::LogMessage(msg) => {
                            self.add_log(msg);
                        }
                        ContextAction::CloseMenu => {
                            // Menu will be closed below
                        }
                    }
                }
            }
        }

        // Close context menu if clicking elsewhere or if it was handled
        if (ui.input(|i| i.pointer.primary_clicked()) || !context_actions.is_empty()) && self.show_context_menu {
            self.show_context_menu = false;
            self.context_menu_file = None;
        }

        ui.add_space(8.0);
        ui.separator();
        ui.add_space(5.0);

        // Compact file operations section
        ui.horizontal(|ui| {
            ui.label("🔧 Operations:");
            if ui.button("📋 Copy").on_hover_text("Copy selected files").clicked() {
                self.copy_selected_files();
            }
            if ui.button("✂️ Cut").on_hover_text("Cut selected files").clicked() {
                self.cut_selected_files();
            }
            if ui.button("📄 Paste").on_hover_text("Paste files").clicked() {
                self.paste_files();
            }
            ui.separator();

            // Checksum functionality
            if ui.button("🔐 Checksum").on_hover_text("Calculate checksum for selected files").clicked() {
                self.calculate_checksum_for_selected();
            }

            // Speed limiter
            ui.separator();
            let tab = &mut self.filepane_tabs[self.filepane_active_tab];
            ui.label("Speed:");
            let current_speed = tab.copy_speed_limit_mb_per_sec;
            ui.add_sized(
                [80.0, 20.0],
                egui::Slider::new(&mut tab.copy_speed_limit_mb_per_sec, 1.0..=100.0)
                    .text(format!("{} MB/s", current_speed))
            );

            ui.separator();
            if ui.button("🗑️ Delete").on_hover_text("Delete selected files").clicked() {
                self.delete_selected_files();
            }
            if ui.button("📁 New Folder").on_hover_text("Create new folder").clicked() {
                self.create_new_folder();
            }
            if ui.button("💾 Save History").on_hover_text("Save conversation history to file").clicked() {
                self.save_current_conversation();
            }

            ui.separator();

            // Show current selections count
            let current_tab = &self.filepane_tabs[self.filepane_active_tab];
            let selected_count = current_tab.selected_left.len() + current_tab.selected_right.len();
            let checked_count = current_tab.left_checkboxes.len() + current_tab.right_checkboxes.len();

            if selected_count > 0 {
                ui.label(format!("📌 Selected: {}", selected_count));
            }
            if checked_count > 0 {
                ui.label(format!("☑️ Checked: {}", checked_count));
            }
        });

        ui.add_space(8.0);

        // Compact settings section
        ui.horizontal(|ui| {
            ui.label("⚙️ Settings:");
            if ui.checkbox(&mut self.show_window_grid, "Hidden files").changed() {
                // Refresh both panels when setting changes
            }
            ui.separator();

            // Checksum algorithm selection
            let tab = &mut self.filepane_tabs[self.filepane_active_tab];
            ui.label("Checksum:");

            let md5_selected = tab.checksum_algorithm == ChecksumAlgorithm::MD5;
            if ui.selectable_label(md5_selected, "MD5").clicked() {
                tab.checksum_algorithm = ChecksumAlgorithm::MD5;
            }
            let sha1_selected = tab.checksum_algorithm == ChecksumAlgorithm::SHA1;
            if ui.selectable_label(sha1_selected, "SHA1").clicked() {
                tab.checksum_algorithm = ChecksumAlgorithm::SHA1;
            }
            let sha256_selected = tab.checksum_algorithm == ChecksumAlgorithm::SHA256;
            if ui.selectable_label(sha256_selected, "SHA256").clicked() {
                tab.checksum_algorithm = ChecksumAlgorithm::SHA256;
            }
            let crc32_selected = tab.checksum_algorithm == ChecksumAlgorithm::CRC32;
            if ui.selectable_label(crc32_selected, "CRC32").clicked() {
                tab.checksum_algorithm = ChecksumAlgorithm::CRC32;
            }

            ui.separator();
            if ui.selectable_label(self.theme == Theme::Dark, "🌙 Dark").clicked() {
                self.theme = Theme::Dark;
                self.save_config();
            }
            if ui.selectable_label(self.theme == Theme::Light, "☀️ Light").clicked() {
                self.theme = Theme::Light;
                self.save_config();
            }
        });

        // Show confirmation dialog if needed
        self.show_filepane_confirmation_dialog(ui);
    }

    fn show_file_panel_header_with_checkboxes(&mut self, ui: &mut egui::Ui, panel_index: usize) {
        let tab = &mut self.filepane_tabs[self.filepane_active_tab];
        let (path, should_navigate, should_toggle_all) = if panel_index == 0 {
            let mut new_path = tab.left_path.clone();
            let mut should_navigate = None as Option<String>;
            let mut should_toggle_all = false;

            ui.horizontal(|ui| {
                // Column name
                let column_name = if self.filepane_swap_columns { "Right" } else { "Left" };
                ui.label(format!("📁 {}", column_name));

                ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
                    // Toggle all checkbox button (only show when checkboxes are enabled)
                    if tab.show_checkboxes {
                        if ui.button("☑️ All").on_hover_text("Toggle all checkboxes in this column").clicked() {
                            should_toggle_all = true;
                        }
                        ui.separator();
                    }

                    if ui.button("📁 ↑").on_hover_text("Parent directory").clicked() {
                        should_navigate = Some("parent".to_string());
                    }
                    if ui.button("🔄").on_hover_text("Refresh").clicked() {
                        should_navigate = Some("refresh".to_string());
                    }
                });
            });

            ui.horizontal(|ui| {
                ui.label("📍");
                if ui.add_sized(
                    [ui.available_width(), 20.0],
                    egui::TextEdit::singleline(&mut new_path)
                ).changed() {
                    should_navigate = Some(new_path.clone());
                }
            });

            (new_path, should_navigate, should_toggle_all)
        } else {
            let mut new_path = tab.right_path.clone();
            let mut should_navigate = None as Option<String>;
            let mut should_toggle_all = false;

            ui.horizontal(|ui| {
                // Column name
                let column_name = if self.filepane_swap_columns { "Left" } else { "Right" };
                ui.label(format!("📁 {}", column_name));

                ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
                    // Toggle all checkbox button (only show when checkboxes are enabled)
                    if tab.show_checkboxes {
                        if ui.button("☑️ All").on_hover_text("Toggle all checkboxes in this column").clicked() {
                            should_toggle_all = true;
                        }
                        ui.separator();
                    }

                    if ui.button("📁 ↑").on_hover_text("Parent directory").clicked() {
                        should_navigate = Some("parent".to_string());
                    }
                    if ui.button("🔄").on_hover_text("Refresh").clicked() {
                        should_navigate = Some("refresh".to_string());
                    }
                });
            });

            ui.horizontal(|ui| {
                ui.label("📍");
                if ui.add_sized(
                    [ui.available_width(), 20.0],
                    egui::TextEdit::singleline(&mut new_path)
                ).changed() {
                    should_navigate = Some(new_path.clone());
                }
            });

            (new_path, should_navigate, should_toggle_all)
        };

        // Handle toggle all action
        if should_toggle_all {
            let tab = &mut self.filepane_tabs[self.filepane_active_tab];
            let filter = tab.filter.to_lowercase();

            // Get current file list to apply toggle
            if let Ok(entries) = std::fs::read_dir(if panel_index == 0 { &tab.left_path } else { &tab.right_path }) {
                for entry in entries.flatten() {
                    if let Ok(file_info) = FileInfo::new(entry.path()) {
                        // Apply filter
                        if !filter.is_empty() && !file_info.name.to_lowercase().contains(&filter) {
                            continue;
                        }

                        // Skip hidden files if not showing them
                        if !self.show_window_grid && file_info.name.starts_with('.') {
                            continue;
                        }

                        // Toggle checkbox state
                        if panel_index == 0 {
                            if tab.left_checkboxes.contains(&file_info.name) {
                                tab.left_checkboxes.remove(&file_info.name);
                            } else {
                                tab.left_checkboxes.insert(file_info.name);
                            }
                        } else {
                            if tab.right_checkboxes.contains(&file_info.name) {
                                tab.right_checkboxes.remove(&file_info.name);
                            } else {
                                tab.right_checkboxes.insert(file_info.name);
                            }
                        }
                    }
                }
            }
        }

        // Handle navigation actions
        if let Some(action) = should_navigate {
            let tab = &mut self.filepane_tabs[self.filepane_active_tab];
            if action == "parent" {
                if panel_index == 0 {
                    if let Some(parent) = std::path::Path::new(&tab.left_path).parent() {
                        tab.left_path = parent.to_string_lossy().to_string();
                        tab.selected_left.clear();
                        tab.left_checkboxes.clear();
                    }
                } else {
                    if let Some(parent) = std::path::Path::new(&tab.right_path).parent() {
                        tab.right_path = parent.to_string_lossy().to_string();
                        tab.selected_right.clear();
                        tab.right_checkboxes.clear();
                    }
                }
            } else if action == "refresh" {
                // Refresh is handled when reading the directory
            } else {
                // Path was manually edited
                if panel_index == 0 {
                    tab.left_path = action;
                    tab.selected_left.clear();
                    tab.left_checkboxes.clear();
                } else {
                    tab.right_path = action;
                    tab.selected_right.clear();
                    tab.right_checkboxes.clear();
                }
            }
        }
    }

    fn show_file_panel_with_checkboxes(&mut self, ui: &mut egui::Ui, path: &str, panel_index: usize) {
        let path_buf = std::path::Path::new(path);
        let tab = &mut self.filepane_tabs[self.filepane_active_tab];
        let filter = tab.filter.clone();
        let show_hidden = self.show_window_grid;

        // Pre-calculate all needed data to avoid borrowing issues
        let file_infos_with_display_names: Vec<(FileInfo, String)> = {
            // This will be filled in the next section
            Vec::new()
        };

        if let Ok(entries) = std::fs::read_dir(path_buf) {
            let mut file_infos: Vec<FileInfo> = Vec::new();

            // Add parent directory entry if not at root
            if let Some(parent) = path_buf.parent() {
                if let Ok(parent_info) = FileInfo::new(parent.to_path_buf()) {
                    file_infos.push(parent_info);
                }
            }

            // Add directory entries
            for entry in entries.flatten() {
                if let Ok(file_info) = FileInfo::new(entry.path()) {
                    // Apply filter
                    if !filter.is_empty() {
                        if !file_info.name.to_lowercase().contains(&filter.to_lowercase()) {
                            continue;
                        }
                    }

                    // Skip hidden files if not showing them
                    if !show_hidden && file_info.name.starts_with('.') {
                        continue;
                    }

                    file_infos.push(file_info);
                }
            }

            // Sort: directories first, then files, both by name
            file_infos.sort_by(|a, b| {
                match (a.is_directory, b.is_directory) {
                    (true, false) => std::cmp::Ordering::Less,
                    (false, true) => std::cmp::Ordering::Greater,
                    _ => a.name.to_lowercase().cmp(&b.name.to_lowercase()),
                }
            });

            // Get current selections and checkboxes
            let (current_selections, current_checkboxes) = if panel_index == 0 {
                (tab.selected_left.clone(), tab.left_checkboxes.clone())
            } else {
                (tab.selected_right.clone(), tab.right_checkboxes.clone())
            };

            let mut selections_to_update = current_selections.clone();
            let mut checkboxes_to_update = current_checkboxes.clone();
            let mut should_navigate_to = None as Option<String>;

            // Pre-calculate formatted file sizes to avoid borrowing issues
            let file_infos_with_sizes: Vec<(FileInfo, String)> = file_infos.into_iter()
                .map(|info| {
                    let size_str = if info.is_directory {
                        String::new()
                    } else {
                        const UNITS: &[&str] = &["B", "KB", "MB", "GB", "TB"];
                        let mut size = info.size as f64;
                        let mut unit_index = 0;

                        while size >= 1024.0 && unit_index < UNITS.len() - 1 {
                            size /= 1024.0;
                            unit_index += 1;
                        }

                        if unit_index == 0 {
                            format!("{} {}", size as u64, UNITS[unit_index])
                        } else {
                            format!("{:.1} {}", size, UNITS[unit_index])
                        }
                    };
                    (info, size_str)
                })
                .collect();

            // Show file list
            egui::ScrollArea::vertical()
                .auto_shrink([false, true])
                .show(ui, |ui| {
                    for (file_info, size_str) in &file_infos_with_sizes {
                        let is_selected = current_selections.contains(&file_info.name);
                        let _is_checked = current_checkboxes.contains(&file_info.name);

                        let response = ui.horizontal(|ui| {
                            // Show checkbox if enabled
                            if tab.show_checkboxes {
                                let mut is_checked = checkboxes_to_update.contains(&file_info.name);
                                let checkbox_response = ui.checkbox(&mut is_checked, "");
                                if checkbox_response.changed() {
                                    if is_checked {
                                        checkboxes_to_update.insert(file_info.name.clone());
                                    } else {
                                        checkboxes_to_update.remove(&file_info.name);
                                    }
                                }
                            }

                            let icon = if file_info.is_directory { "📁" } else { "📄" };
                            ui.label(icon);

                            // Calculate available width for filename
                            let checkbox_width = if tab.show_checkboxes { 25.0 } else { 0.0 };
                            let available_width = ui.available_width() - 100.0 - checkbox_width;
                            // Use a simple truncation method to avoid borrowing self
                            let max_chars = (available_width / 8.0) as usize;
                            let display_name = if file_info.name.len() <= max_chars {
                                file_info.name.clone()
                            } else if max_chars <= 3 {
                                "...".to_string()
                            } else {
                                format!("{}...", &file_info.name[..max_chars.saturating_sub(3)])
                            };

                            let name_label = if file_info.is_directory {
                                egui::RichText::new(display_name.clone()).strong()
                            } else {
                                egui::RichText::new(display_name.clone())
                            };

                            let label_response = ui.selectable_label(is_selected, name_label);
                            if label_response.hovered() && file_info.name.len() > display_name.len() {
                                label_response.on_hover_text(&file_info.name);
                            }

                            // Show file size for files
                            if !file_info.is_directory {
                                ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
                                    ui.label(size_str);
                                });
                            }
                        });

                        // Handle selection
                        if response.response.clicked() {
                            let shift_pressed = ui.input(|i| i.modifiers.shift);
                            let ctrl_pressed = ui.input(|i| i.modifiers.ctrl);

                            if shift_pressed {
                                // Multi-selection with Shift
                                if !selections_to_update.contains(&file_info.name) {
                                    selections_to_update.push(file_info.name.clone());
                                }
                            } else if ctrl_pressed {
                                // Toggle selection with Ctrl
                                if let Some(pos) = selections_to_update.iter().position(|name| name == &file_info.name) {
                                    selections_to_update.remove(pos);
                                } else {
                                    selections_to_update.push(file_info.name.clone());
                                }
                            } else {
                                // Single selection
                                selections_to_update.clear();
                                selections_to_update.push(file_info.name.clone());
                            }
                        }

                        // Handle right-click for context menu
                        if response.response.secondary_clicked() {
                            self.context_menu_file = Some((file_info.clone(), panel_index));
                            self.show_context_menu = true;
                            // Also select the file for context operations
                            selections_to_update.clear();
                            selections_to_update.push(file_info.name.clone());
                        }

                        // Handle Enter key for directory navigation
                        if response.response.has_focus() && ui.input(|i| i.key_pressed(egui::Key::Enter)) && file_info.is_directory {
                            should_navigate_to = Some(file_info.path.clone());
                        }

                        // Handle double-click for navigation
                        if response.response.double_clicked() && file_info.is_directory {
                            should_navigate_to = Some(file_info.path.clone());
                        }
                    }
                });

            // Update selections and checkboxes after UI is done
            let tab = &mut self.filepane_tabs[self.filepane_active_tab];
            if panel_index == 0 {
                tab.selected_left = selections_to_update;
                tab.left_checkboxes = checkboxes_to_update;
            } else {
                tab.selected_right = selections_to_update;
                tab.right_checkboxes = checkboxes_to_update;
            }

            // Handle navigation
            if let Some(target_path) = should_navigate_to {
                if panel_index == 0 {
                    tab.left_path = target_path;
                    tab.selected_left.clear();
                    tab.left_checkboxes.clear();
                } else {
                    tab.right_path = target_path;
                    tab.selected_right.clear();
                    tab.right_checkboxes.clear();
                }
            }
        } else {
            ui.colored_label(egui::Color32::RED, "❌ Cannot access directory");
        }
    }

    fn format_file_size(&self, size: u64) -> String {
        const UNITS: &[&str] = &["B", "KB", "MB", "GB", "TB"];
        let mut size = size as f64;
        let mut unit_index = 0;

        while size >= 1024.0 && unit_index < UNITS.len() - 1 {
            size /= 1024.0;
            unit_index += 1;
        }

        if unit_index == 0 {
            format!("{} {}", size as u64, UNITS[unit_index])
        } else {
            format!("{:.1} {}", size, UNITS[unit_index])
        }
    }

    fn simple_truncate_filename(&self, name: &str, max_width: f32) -> String {
        // Simple character-based truncation (approximation)
        let max_chars = (max_width / 8.0) as usize; // Assume ~8 pixels per character

        if name.len() <= max_chars {
            return name.to_string();
        }

        if max_chars <= 3 {
            return "...".to_string();
        }

        format!("{}...", &name[..max_chars.saturating_sub(3)])
    }

    fn truncate_filename(&self, name: &str, max_width: f32, ui: &egui::Ui) -> String {
        // First, check if the full name fits
        if ui.painter().layout_no_wrap(
            name.to_string(),
            ui.style().text_styles.get(&egui::TextStyle::Body).unwrap().clone(),
            egui::Color32::WHITE,
        ).size().x <= max_width {
            return name.to_string();
        }

        // If not, truncate with ellipsis
        let ellipsis = "...";
        let ellipsis_width = ui.painter().layout_no_wrap(
            ellipsis.to_string(),
            ui.style().text_styles.get(&egui::TextStyle::Body).unwrap().clone(),
            egui::Color32::WHITE,
        ).size().x;

        // Start with a reasonable portion of the name
        let mut chars = name.chars().collect::<Vec<char>>();
        let mut start_len = chars.len() / 2; // Start with half

        for _ in 0..10 { // Try up to 10 times to find the right length
            if start_len <= 3 {
                return name.chars().take(3).collect::<String>() + ellipsis;
            }

            let truncated_name: String = chars.iter().take(start_len).collect::<String>() + ellipsis;
            let truncated_width = ui.painter().layout_no_wrap(
                truncated_name.clone(),
                ui.style().text_styles.get(&egui::TextStyle::Body).unwrap().clone(),
                egui::Color32::WHITE,
            ).size().x;

            if truncated_width <= max_width {
                return truncated_name;
            }

            start_len = (start_len * 3) / 4; // Reduce by 25% and try again
        }

        // Fallback: return first 5 chars + ellipsis
        name.chars().take(5).collect::<String>() + ellipsis
    }

    
    fn copy_selected_files(&mut self) {
        if self.filepane_active_tab < self.filepane_tabs.len() {
            let tab = &self.filepane_tabs[self.filepane_active_tab];
            let left_count = tab.selected_left.len();
            let right_count = tab.selected_right.len();

            if left_count > 0 {
                self.add_log(format!("Copied {} files from left panel", left_count));
            }
            if right_count > 0 {
                self.add_log(format!("Copied {} files from right panel", right_count));
            }

            if left_count == 0 && right_count == 0 {
                self.add_log("No files selected to copy".to_string());
            }
        }
    }

    fn cut_selected_files(&mut self) {
        if self.filepane_active_tab < self.filepane_tabs.len() {
            let tab = &self.filepane_tabs[self.filepane_active_tab];
            let left_count = tab.selected_left.len();
            let right_count = tab.selected_right.len();

            if left_count > 0 {
                self.add_log(format!("Cut {} files from left panel", left_count));
            }
            if right_count > 0 {
                self.add_log(format!("Cut {} files from right panel", right_count));
            }

            if left_count == 0 && right_count == 0 {
                self.add_log("No files selected to cut".to_string());
            }
        }
    }

    fn paste_files(&mut self) {
        self.add_log("Paste files (placeholder)".to_string());
    }

    fn delete_selected_files(&mut self) {
        if self.filepane_active_tab < self.filepane_tabs.len() {
            let left_count = self.filepane_tabs[self.filepane_active_tab].selected_left.len();
            let right_count = self.filepane_tabs[self.filepane_active_tab].selected_right.len();

            if left_count > 0 {
                self.add_log(format!("Deleted {} files from left panel", left_count));
                self.filepane_tabs[self.filepane_active_tab].selected_left.clear();
            }
            if right_count > 0 {
                self.add_log(format!("Deleted {} files from right panel", right_count));
                self.filepane_tabs[self.filepane_active_tab].selected_right.clear();
            }

            if left_count == 0 && right_count == 0 {
                self.add_log("No files selected to delete".to_string());
            }
        }
    }

    fn create_new_folder(&mut self) {
        self.add_log("Create new folder (placeholder)".to_string());
    }

    fn calculate_checksum_for_selected(&mut self) {
        if self.filepane_active_tab >= self.filepane_tabs.len() {
            return;
        }

        let tab = &self.filepane_tabs[self.filepane_active_tab];
        let algorithm = tab.checksum_algorithm.clone();

        // Get all selected files from both panels
        let mut files_to_check = Vec::new();

        // From left panel (checkboxes and selections)
        for filename in &tab.left_checkboxes {
            let path = format!("{}\\{}", tab.left_path, filename);
            files_to_check.push(path);
        }
        for filename in &tab.selected_left {
            let path = format!("{}\\{}", tab.left_path, filename);
            if !files_to_check.contains(&path) {
                files_to_check.push(path);
            }
        }

        // From right panel (checkboxes and selections)
        for filename in &tab.right_checkboxes {
            let path = format!("{}\\{}", tab.right_path, filename);
            files_to_check.push(path);
        }
        for filename in &tab.selected_right {
            let path = format!("{}\\{}", tab.right_path, filename);
            if !files_to_check.contains(&path) {
                files_to_check.push(path);
            }
        }

        if files_to_check.is_empty() {
            self.add_log("No files selected for checksum calculation".to_string());
            return;
        }

        self.add_log(format!("Calculating {} checksum for {} files", algorithm.name(), files_to_check.len()));

        for file_path in files_to_check {
            // Create checksum command
            let command = FilepaneCommand::CalculateChecksum {
                path: file_path,
                algorithm: algorithm.clone(),
            };

            // Execute the checksum calculation
            self.execute_command(&command);

            // Add to command history
            if self.filepane_active_tab < self.filepane_tabs.len() {
                let tab = &mut self.filepane_tabs[self.filepane_active_tab];
                tab.command_history.push(command);
                tab.undo_stack.clear();
            }
        }
    }

    // Enhanced copy functionality with speed limiting
    fn copy_files_with_limit(&mut self, source_files: Vec<String>, dest_path: &str, speed_limit_mb_per_sec: f64) {
        let mut total_bytes_copied = 0u64;
        let batch_size = (speed_limit_mb_per_sec * 1024.0 * 1024.0) as u64; // Convert MB to bytes

        for (index, file_path) in source_files.iter().enumerate() {
            // Simple placeholder implementation - in a real implementation, this would:
            // 1. Read file in chunks
            // 2. Write to destination
            // 3. Add delays to respect speed limit
            // 4. Handle file permissions and errors

            let dest_file = format!("{}\\{}", dest_path,
                std::path::Path::new(file_path)
                    .file_name()
                    .and_then(|name| name.to_str())
                    .unwrap_or("unknown")
            );

            self.add_log(format!("Copying {}/{}: {} -> {}", index + 1, source_files.len(), file_path, dest_file));

            // Simulate speed limiting delay
            if index > 0 && index % 5 == 0 {
                self.add_log(format!("Speed limiting at {} MB/s", speed_limit_mb_per_sec));
            }
        }

        self.add_log(format!("Copy operation completed. Total files: {}", source_files.len()));
    }

    // Filepane command methods
    fn copy_files_to_opposite_panel(&mut self) {
        if self.filepane_active_tab >= self.filepane_tabs.len() {
            return;
        }

        // Collect all needed data to avoid borrowing issues
        let (source_path, dest_path, left_checkboxes, right_checkboxes, selected_left, selected_right, speed_limit) = {
            let tab = &self.filepane_tabs[self.filepane_active_tab];
            let (src, dst) = if self.filepane_swap_columns {
                (tab.right_path.clone(), tab.left_path.clone())
            } else {
                (tab.left_path.clone(), tab.right_path.clone())
            };
            (
                src,
                dst,
                tab.left_checkboxes.clone(),
                tab.right_checkboxes.clone(),
                tab.selected_left.clone(),
                tab.selected_right.clone(),
                tab.copy_speed_limit_mb_per_sec,
            )
        };

        // Get files from checkboxes and selections
        let mut source_files = Vec::new();

        // From checkboxes (priority)
        for filename in &left_checkboxes {
            source_files.push(format!("{}\\{}", source_path, filename));
        }
        for filename in &right_checkboxes {
            source_files.push(format!("{}\\{}", source_path, filename));
        }

        // From selections if no checkboxes
        if source_files.is_empty() {
            for filename in &selected_left {
                source_files.push(format!("{}\\{}", source_path, filename));
            }
            for filename in &selected_right {
                source_files.push(format!("{}\\{}", source_path, filename));
            }
        }

        if source_files.is_empty() {
            self.add_log("No files selected to copy".to_string());
            return;
        }

        // Execute the copy with speed limiting
        self.copy_files_with_limit(source_files, &dest_path, speed_limit);
    }

    fn duplicate_current_tab(&mut self) {
        if self.filepane_active_tab >= self.filepane_tabs.len() {
            return;
        }

        let new_tab_name = format!("{} Copy", self.filepane_tabs[self.filepane_active_tab].name);

        let new_tab = FilepaneTab::new(
            new_tab_name,
            self.filepane_tabs[self.filepane_active_tab].left_path.clone(),
            self.filepane_tabs[self.filepane_active_tab].right_path.clone(),
        );

        self.filepane_tabs.insert(self.filepane_active_tab + 1, new_tab);
        self.filepane_active_tab += 1;

        self.add_log(format!("Duplicated tab to: {}", self.filepane_tabs[self.filepane_active_tab].name));
    }

    fn undo_last_action(&mut self) {
        if self.filepane_active_tab >= self.filepane_tabs.len() {
            return;
        }

        let command = {
            let tab = &mut self.filepane_tabs[self.filepane_active_tab];
            tab.undo_stack.pop()
        };

        if let Some(command) = command {
            // Prepare log message
            let log_message = match &command {
                FilepaneCommand::CopyFile { source, destination } => {
                    format!("Undo: Copy {} -> {}", source, destination)
                }
                FilepaneCommand::MoveFile { source, destination } => {
                    format!("Undo: Move {} -> {}", source, destination)
                }
                FilepaneCommand::DeleteFile { path } => {
                    format!("Undo: Delete {} (cannot restore)", path)
                }
                FilepaneCommand::CreateDirectory { path } => {
                    format!("Undo: Create {}", path)
                }
                FilepaneCommand::RenameFile { old_path, new_path } => {
                    format!("Undo: Rename {} -> {}", new_path, old_path)
                }
                FilepaneCommand::ChangeDirectory { panel, new_path: _ } => {
                    format!("Undo: Change directory for panel {}", panel)
                }
                FilepaneCommand::CalculateChecksum { path, algorithm } => {
                    format!("Undo: {} checksum for {}", algorithm.name(), path)
                }
            };

            self.add_log(log_message);

            // Push to redo stack
            let tab = &mut self.filepane_tabs[self.filepane_active_tab];
            tab.redo_stack.push(command);
        }
    }

    fn redo_last_action(&mut self) {
        if self.filepane_active_tab >= self.filepane_tabs.len() {
            return;
        }

        let command = {
            let tab = &mut self.filepane_tabs[self.filepane_active_tab];
            tab.redo_stack.pop()
        };

        if let Some(command) = command {
            // Prepare log message
            let log_message = match &command {
                FilepaneCommand::CopyFile { source, destination } => {
                    format!("Redo: Copy {} -> {}", source, destination)
                }
                FilepaneCommand::MoveFile { source, destination } => {
                    format!("Redo: Move {} -> {}", source, destination)
                }
                FilepaneCommand::DeleteFile { path } => {
                    format!("Redo: Delete {} (cannot restore)", path)
                }
                FilepaneCommand::CreateDirectory { path } => {
                    format!("Redo: Create {}", path)
                }
                FilepaneCommand::RenameFile { old_path, new_path } => {
                    format!("Redo: Rename {} -> {}", old_path, new_path)
                }
                FilepaneCommand::ChangeDirectory { panel, new_path: _ } => {
                    format!("Redo: Change directory for panel {}", panel)
                }
                FilepaneCommand::CalculateChecksum { path, algorithm } => {
                    format!("Redo: {} checksum for {}", algorithm.name(), path)
                }
            };

            self.add_log(log_message);

            // Push to undo stack
            let tab = &mut self.filepane_tabs[self.filepane_active_tab];
            tab.undo_stack.push(command);
        }
    }

    fn save_current_paths(&mut self) {
        if self.filepane_active_tab >= self.filepane_tabs.len() {
            return;
        }

        let tab = &self.filepane_tabs[self.filepane_active_tab];

        // Simple INI format using file system operations
        let ini_content = format!(
            "[Filepane]\n\
            left_path={}\n\
            right_path={}\n\
            filter={}\n\
            show_checkboxes={}\n",
            tab.left_path.replace('\\', "/"),
            tab.right_path.replace('\\', "/"),
            tab.filter,
            tab.show_checkboxes
        );

        if let Err(e) = std::fs::write(&self.filepane_config_path, ini_content) {
            self.add_log(format!("Failed to save paths: {}", e));
        } else {
            self.add_log(format!("Saved current paths to {}", self.filepane_config_path));
        }
    }

    fn save_all_tabs(&mut self) {
        let mut ini_content = String::from("[FilepaneTabs]\n");

        for (i, tab) in self.filepane_tabs.iter().enumerate() {
            ini_content.push_str(&format!(
                "[Tab{}]\n\
                name={}\n\
                left_path={}\n\
                right_path={}\n\
                filter={}\n\
                show_checkboxes={}\n",
                i,
                tab.name,
                tab.left_path.replace('\\', "/"),
                tab.right_path.replace('\\', "/"),
                tab.filter,
                tab.show_checkboxes
            ));
        }

        ini_content.push_str(&format!(
            "\n[Settings]\n\
            active_tab={}\n\
            swap_columns={}\n",
            self.filepane_active_tab,
            self.filepane_swap_columns
        ));

        let filename = format!("filepane_all_tabs.ini");
        if let Err(e) = std::fs::write(&filename, ini_content) {
            self.add_log(format!("Failed to save all tabs: {}", e));
        } else {
            self.add_log(format!("Saved {} tabs to {}", self.filepane_tabs.len(), filename));
        }
    }

    fn load_paths_from_config(&mut self) {
        if !std::path::Path::new(&self.filepane_config_path).exists() {
            self.add_log("No config file found".to_string());
            return;
        }

        if let Ok(content) = std::fs::read_to_string(&self.filepane_config_path) {
            let mut left_path = String::new();
            let mut right_path = String::new();
            let mut filter = String::new();
            let mut show_checkboxes = false;

            for line in content.lines() {
                if line.starts_with("left_path=") {
                    left_path = line.split('=').nth(1).unwrap_or("").replace('/', "\\");
                } else if line.starts_with("right_path=") {
                    right_path = line.split('=').nth(1).unwrap_or("").replace('/', "\\");
                } else if line.starts_with("filter=") {
                    filter = line.split('=').nth(1).unwrap_or("").to_string();
                } else if line.starts_with("show_checkboxes=") {
                    show_checkboxes = line.split('=').nth(1).unwrap_or("false") == "true";
                }
            }

            if self.filepane_active_tab < self.filepane_tabs.len() {
                let tab = &mut self.filepane_tabs[self.filepane_active_tab];
                tab.left_path = left_path;
                tab.right_path = right_path;
                tab.filter = filter;
                tab.show_checkboxes = show_checkboxes;

                self.add_log(format!("Loaded paths from {}", self.filepane_config_path));
            }
        }
    }

    fn show_filepane_confirmation_dialog(&mut self, ui: &mut egui::Ui) {
        let should_show = self.filepane_show_confirm;
        let confirm_message = self.filepane_confirm_message.clone();
        let confirm_action = self.filepane_confirm_action.clone();

        if should_show && confirm_action.is_some() {
            egui::Window::new("⚠️ Confirm Action")
                .collapsible(false)
                .resizable(false)
                .anchor(egui::Align2::CENTER_CENTER, egui::vec2(0.0, 0.0))
                .show(ui.ctx(), |ui| {
                    ui.vertical_centered(|ui| {
                        ui.add_space(10.0);
                        ui.label(&confirm_message);
                        ui.add_space(20.0);

                        ui.horizontal(|ui| {
                            if ui.button("✅ Yes").clicked() {
                                if let Some(action) = confirm_action {
                                    self.add_log("Action confirmed".to_string());
                                    self.execute_command(&action);
                                }
                                self.filepane_show_confirm = false;
                                self.filepane_confirm_action = None;
                                self.filepane_confirm_message.clear();
                            }

                            if ui.button("❌ No").clicked() {
                                self.add_log("Action cancelled".to_string());
                                self.filepane_show_confirm = false;
                                self.filepane_confirm_action = None;
                                self.filepane_confirm_message.clear();
                            }
                        });

                        ui.add_space(10.0);
                    });
                });
        }
    }

    fn show_file_properties(&mut self, file_info: &FileInfo) {
        // Create a simple properties display in the log for now
        let file_type = if file_info.is_directory { "Directory" } else { "File" };
        let modified_time = file_info.modified
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap_or_default()
            .as_secs();

        let formatted_time = std::time::UNIX_EPOCH + std::time::Duration::from_secs(modified_time);

        self.add_log(format!("=== Properties for {} ===", file_info.name));
        self.add_log(format!("Type: {}", file_type));
        self.add_log(format!("Size: {} bytes", file_info.size));
        self.add_log(format!("Modified: {:?}", formatted_time));
        self.add_log(format!("Path: {}", file_info.path));

        if let Some(ref ext) = file_info.extension {
            self.add_log(format!("Extension: {}", ext));
        }

        self.add_log("=================================".to_string());
    }

    fn execute_command(&mut self, command: &FilepaneCommand) {
        match command {
            FilepaneCommand::CopyFile { source, destination } => {
                // Placeholder for actual file copy
                self.add_log(format!("Copying {} to {}", source, destination));
            }
            FilepaneCommand::MoveFile { source, destination } => {
                // Placeholder for actual file move
                self.add_log(format!("Moving {} to {}", source, destination));
            }
            FilepaneCommand::DeleteFile { path } => {
                // Placeholder for actual file deletion
                self.add_log(format!("Deleting {}", path));
            }
            FilepaneCommand::CreateDirectory { path } => {
                // Placeholder for actual directory creation
                self.add_log(format!("Creating directory {}", path));
            }
            FilepaneCommand::RenameFile { old_path, new_path } => {
                // Placeholder for actual rename
                self.add_log(format!("Renaming {} to {}", old_path, new_path));
            }
            FilepaneCommand::ChangeDirectory { panel, new_path } => {
                // Placeholder for directory change
                self.add_log(format!("Changing panel {} to {}", panel, new_path));
            }
            FilepaneCommand::CalculateChecksum { path, algorithm } => {
                self.add_log(format!("Calculating {} checksum for {}", algorithm.name(), path));
            }
        }

        // Add to command history
        if self.filepane_active_tab < self.filepane_tabs.len() {
            let tab = &mut self.filepane_tabs[self.filepane_active_tab];
            tab.command_history.push(command.clone());
            tab.undo_stack.clear(); // Clear redo stack on new action
        }
    }

    fn open_file_with_system(&self, path: &str) {
        #[cfg(target_os = "windows")]
        {
            let _ = std::process::Command::new("cmd")
                .args(&["/C", "start", "", path])
                .spawn();
        }

        #[cfg(target_os = "linux")]
        {
            let _ = std::process::Command::new("xdg-open")
                .arg(path)
                .spawn();
        }

        #[cfg(target_os = "macos")]
        {
            let _ = std::process::Command::new("open")
                .arg(path)
                .spawn();
        }
    }

    fn save_conversation_history(&self, conversation_text: &str) -> Result<String, String> {
        use std::fs;

        // Get current timestamp
        let now = chrono::Local::now();
        let timestamp = now.format("%Y%m%d_%H%M%S").to_string();

        // Create filename
        let filename = format!("history_{}.txt", timestamp);

        // Get winshell directory path
        let winshell_path = std::env::current_exe()
            .ok()
            .and_then(|path| path.parent().map(|p| p.to_path_buf()))
            .unwrap_or_else(|| std::path::PathBuf::from("."));

        let file_path = winshell_path.join(&filename);

        // Create conversation history content
        let mut content = format!(
            "WinShell Conversation History\n\
            =============================\n\
            Timestamp: {}\n\
            Session Date: {}\n\n\
            Conversation:\n\
            ------------\n\
            {}\n\n\
            === End of History ===\n",
            timestamp,
            now.format("%Y-%m-%d %H:%M:%S"),
            conversation_text
        );

        // Add system information
        content.push_str(&format!(
            "\nSystem Info:\n\
            - WinShell Version: 0.1.0\n\
            - Platform: {}\n\
            - Total Log Entries: {}\n",
            std::env::consts::OS,
            self.logs.len()
        ));

        // Add active tabs information
        if !self.filepane_tabs.is_empty() {
            content.push_str(&format!(
                "\nFilepane Info:\n\
                - Active Tab: {}\n\
                - Total Tabs: {}\n\
                - Columns Swapped: {}\n",
                self.filepane_active_tab + 1,
                self.filepane_tabs.len(),
                if self.filepane_swap_columns { "Yes" } else { "No" }
            ));

            // Add active tab paths
            if let Some(active_tab) = self.filepane_tabs.get(self.filepane_active_tab) {
                content.push_str(&format!(
                    "  Active Tab Paths:\n\
                    - Left: {}\n\
                    - Right: {}\n",
                    active_tab.left_path,
                    active_tab.right_path
                ));
            }
        }

        // Write to file
        match fs::write(&file_path, content) {
            Ok(_) => {
                Ok(format!("Conversation history saved to: {}", file_path.display()))
            }
            Err(e) => {
                Err(format!("Failed to save conversation history: {}", e))
            }
        }
    }

    fn save_current_conversation(&mut self) {
        // Combine logs and conversation history into a single text
        let mut conversation_text = String::new();

        // Add conversation history if available
        if !self.conversation_history.is_empty() {
            conversation_text.push_str("=== Previous Conversation ===\n");
            for entry in &self.conversation_history {
                conversation_text.push_str(&format!("{}\n", entry));
            }
            conversation_text.push_str("\n");
        }

        // Add current session logs
        conversation_text.push_str("=== Current Session Logs ===\n");
        for (i, log_entry) in self.logs.iter().enumerate() {
            conversation_text.push_str(&format!("[{:03}] {}\n", i + 1, log_entry));
        }

        // Save to file and handle result
        match self.save_conversation_history(&conversation_text) {
            Ok(message) => {
                self.add_log(format!("✅ {}", message));
            }
            Err(error) => {
                self.add_log(format!("❌ {}", error));
            }
        }
    }

    fn show_kill_confirm_dialog(&mut self, ctx: &egui::Context) {
        if let Some(pid) = self.kill_confirm_pid {
            let mut open = true;
            egui::Window::new("⚠️ Confirm Kill Process")
                .collapsible(false)
                .resizable(false)
                .anchor(egui::Align2::CENTER_CENTER, egui::vec2(0.0, 0.0))
                .open(&mut open)
                .show(ctx, |ui| {
                    ui.set_min_width(300.0);
                    
                    ui.vertical_centered(|ui| {
                        ui.heading(format!("Are you sure you want to kill process {}?", pid));
                        ui.add_space(10.0);
                        
                        // Show thumbnail if available
                        if let Some(texture) = &self.kill_confirm_thumbnail {
                            ui.add(egui::Image::new(texture).fit_to_exact_size(egui::vec2(240.0, 160.0)));
                            ui.add_space(10.0);
                        } else {
                            // Try to find process name
                            if let Some(process) = self.processes.iter().find(|p| p.pid == pid) {
                                ui.label(egui::RichText::new(&process.name).size(16.0).strong());
                            }
                            ui.label("(No window thumbnail available)");
                            ui.add_space(10.0);
                        }
                        
                        ui.label("This action cannot be undone and may cause data loss.");
                        ui.add_space(20.0);
                        
                        ui.horizontal(|ui| {
                            if ui.button("❌ Cancel").clicked() {
                                self.kill_confirm_pid = None;
                                self.kill_confirm_thumbnail = None;
                            }
                            
                            if ui.button("⚠️ Yes, Kill Process").clicked() {
                                if self.kill_process(pid) {
                                    self.add_log(format!("Successfully killed process {}", pid));
                                    self.refresh_processes();
                                } else {
                                    self.add_log(format!("Failed to kill process {}", pid));
                                }
                                self.kill_confirm_pid = None;
                                self.kill_confirm_thumbnail = None;
                            }
                        });
                    });
                });
            
            if !open {
                self.kill_confirm_pid = None;
                self.kill_confirm_thumbnail = None;
            }
        }
    }

    fn show_logs_view(&mut self, ui: &mut egui::Ui) {
        egui::ScrollArea::vertical()
            .auto_shrink([false, false])
            .stick_to_bottom(true)
            .show(ui, |ui| {
                ui.heading("📋 Application Log");
                ui.add_space(10.0);

                ui.horizontal(|ui| {
                    if ui.button("🗑 Clear Logs").clicked() {
                        self.logs.clear();
                        self.selected_log_indices.clear();
                        self.add_log("Logs cleared".to_string());
                    }

                    if ui.button("📋 Copy Selected").clicked() {
                        if !self.selected_log_indices.is_empty() {
                            let mut selected_logs: Vec<_> = self.selected_log_indices.iter()
                                .filter_map(|&idx| self.logs.get(idx))
                                .cloned()
                                .collect();
                            selected_logs.sort();
                            let combined = selected_logs.join("\n");
                            ui.output_mut(|o| o.copied_text = combined);
                        }
                    }

                    if ui.button("📋 Copy All").clicked() {
                        let all_logs = self.logs.join("\n");
                        ui.output_mut(|o| o.copied_text = all_logs);
                    }

                    if ui.button("❌ Clear Selection").clicked() {
                        self.selected_log_indices.clear();
                    }

                    ui.label(format!("Selected: {} / {}", self.selected_log_indices.len(), self.logs.len()));
                });

                ui.add_space(5.0);
                ui.label("💡 Tip: Click to select, Ctrl+Click to toggle selection");
                ui.add_space(5.0);
                ui.separator();
                ui.add_space(5.0);

                // Display logs in reverse order (newest first)
                for (idx, log) in self.logs.iter().enumerate().rev() {
                    let is_selected = self.selected_log_indices.contains(&idx);

                    ui.horizontal(|ui| {
                        let response = ui.selectable_label(is_selected, format!("[{}]", idx + 1));
                        if response.clicked() {
                            // Check if Ctrl is held
                            if ui.input(|i| i.modifiers.ctrl || i.modifiers.command) {
                                // Toggle selection
                                if is_selected {
                                    self.selected_log_indices.remove(&idx);
                                } else {
                                    self.selected_log_indices.insert(idx);
                                }
                            } else {
                                // Single selection
                                self.selected_log_indices.clear();
                                self.selected_log_indices.insert(idx);
                            }
                        }
                        ui.label(log);
                    });
                }

                if self.logs.is_empty() {
                    ui.add_space(20.0);
                    ui.label("No log entries yet");
                }
            });
    }

    fn add_log(&mut self, message: String) {
        use chrono::Local;
        let timestamp = Local::now().format("%Y-%m-%d %H:%M:%S");
        let log_entry = format!("{} - {}", timestamp, message);
        self.logs.push(log_entry);

        // Keep only last 1000 log entries to prevent memory bloat
        if self.logs.len() > 1000 {
            self.logs.remove(0);
        }
    }

    fn add_conversation_entry(&mut self, entry: String) {
        use chrono::Local;
        let timestamp = Local::now().format("%Y-%m-%d %H:%M:%S");
        let conversation_entry = format!("[{}] {}", timestamp, entry);
        self.conversation_history.push(conversation_entry);

        // Keep only last 500 conversation entries to prevent memory bloat
        if self.conversation_history.len() > 500 {
            self.conversation_history.remove(0);
        }
    }

    fn open_file_path(&mut self, path: &str) {
        #[cfg(windows)]
        {
            // Open Windows Explorer and select the file
            let _ = std::process::Command::new("explorer")
                .args(&["/select,", path])
                .spawn();
            self.add_log(format!("Opening path in Explorer: {}", path));
        }

        #[cfg(target_os = "linux")]
        {
            // Try to open the file with xdg-open
            if let Some(parent) = std::path::Path::new(path).parent() {
                let _ = std::process::Command::new("xdg-open")
                    .arg(parent)
                    .spawn();
                self.add_log(format!("Opening parent directory: {}", parent.display()));
            }
        }

        #[cfg(target_os = "macos")]
        {
            // Open Finder and select the file
            let _ = std::process::Command::new("open")
                .args(&["-R", path])
                .spawn();
            self.add_log(format!("Opening path in Finder: {}", path));
        }
    }

    fn browse_for_program(&mut self) -> Option<String> {
        // Use native file dialog on Windows
        #[cfg(windows)]
        {
            use windows::Win32::UI::Shell::Common::COMDLG_FILTERSPEC;
            use windows::Win32::UI::Shell::{IFileOpenDialog, FOS_FILEMUSTEXIST, SIGDN_FILESYSPATH};
            use windows::Win32::System::Com::{CoCreateInstance, CoInitializeEx, COINIT_APARTMENTTHREADED, CLSCTX_INPROC_SERVER};
            use windows::core::PCWSTR;

            unsafe {
                // Initialize COM
                let _ = CoInitializeEx(None, COINIT_APARTMENTTHREADED);

                // Create file open dialog
                let dialog: IFileOpenDialog = match CoCreateInstance(
                    &windows::Win32::UI::Shell::FileOpenDialog,
                    None,
                    CLSCTX_INPROC_SERVER,
                ) {
                    Ok(d) => d,
                    Err(e) => {
                        self.add_log(format!("Failed to create file dialog: {}", e));
                        return None;
                    }
                };

                // Set options
                if let Ok(mut options) = dialog.GetOptions() {
                    options |= FOS_FILEMUSTEXIST;
                    let _ = dialog.SetOptions(options);
                }

                // Set file type filter for executables
                let filter_name = windows::core::w!("Executable Files");
                let filter_spec = windows::core::w!("*.exe;*.bat;*.cmd;*.ps1");
                let all_files_name = windows::core::w!("All Files");
                let all_files_spec = windows::core::w!("*.*");

                let filters = [
                    COMDLG_FILTERSPEC {
                        pszName: PCWSTR::from_raw(filter_name.as_ptr()),
                        pszSpec: PCWSTR::from_raw(filter_spec.as_ptr()),
                    },
                    COMDLG_FILTERSPEC {
                        pszName: PCWSTR::from_raw(all_files_name.as_ptr()),
                        pszSpec: PCWSTR::from_raw(all_files_spec.as_ptr()),
                    },
                ];

                let _ = dialog.SetFileTypes(&filters);

                // Show the dialog
                if dialog.Show(None).is_ok() {
                    if let Ok(result) = dialog.GetResult() {
                        if let Ok(path_pwstr) = result.GetDisplayName(SIGDN_FILESYSPATH) {
                            let path_string = path_pwstr.to_string().ok()?;
                            self.add_log(format!("Selected program: {}", path_string));
                            return Some(path_string);
                        }
                    }
                }
            }

            None
        }

        // For Linux/macOS, use a simple text-based approach or a dialog library
        #[cfg(not(windows))]
        {
            self.add_log("File browser not yet implemented on this platform. Please enter the path manually.".to_string());
            None
        }
    }

    fn launch_program(&mut self, program: &str, args: &str, run_as_admin: bool) -> Result<u32, String> {
        // Log the launch attempt
        let launch_info = if args.is_empty() {
            if run_as_admin {
                format!("Launching with elevation: {}", program)
            } else {
                format!("Launching: {}", program)
            }
        } else {
            if run_as_admin {
                format!("Launching with elevation: {} {}", program, args)
            } else {
                format!("Launching: {} {}", program, args)
            }
        };
        self.add_log(launch_info);

        // Windows: Use ShellExecute for elevation
        #[cfg(windows)]
        {
            if run_as_admin {
                use windows::Win32::UI::Shell::{ShellExecuteW, SE_ERR_ACCESSDENIED};
                use windows::Win32::Foundation::HWND;
                use windows::core::PCWSTR;
                use std::os::windows::ffi::OsStrExt;
                use std::ffi::OsStr;

                unsafe {
                    let operation = windows::core::w!("runas");

                    // Convert paths to wide strings
                    let file: Vec<u16> = OsStr::new(program)
                        .encode_wide()
                        .chain(std::iter::once(0))
                        .collect();

                    let parameters: Vec<u16> = if !args.is_empty() {
                        OsStr::new(args)
                            .encode_wide()
                            .chain(std::iter::once(0))
                            .collect()
                    } else {
                        vec![0]
                    };

                    // Get working directory
                    let directory: Vec<u16> = if let Some(parent) = std::path::Path::new(program).parent() {
                        OsStr::new(&parent.to_string_lossy().to_string())
                            .encode_wide()
                            .chain(std::iter::once(0))
                            .collect()
                    } else {
                        vec![0]
                    };

                    let result = ShellExecuteW(
                        HWND(std::ptr::null_mut()),
                        PCWSTR::from_raw(operation.as_ptr()),
                        PCWSTR::from_raw(file.as_ptr()),
                        PCWSTR::from_raw(parameters.as_ptr()),
                        PCWSTR::from_raw(directory.as_ptr()),
                        windows::Win32::UI::WindowsAndMessaging::SW_SHOWNORMAL,
                    );

                    if result.0 as i32 <= 32 {
                        let error_msg = if result.0 as i32 == SE_ERR_ACCESSDENIED as i32 {
                            "Access denied. User canceled the elevation prompt.".to_string()
                        } else {
                            format!("ShellExecute failed with code: {}", result.0 as i32)
                        };
                        self.add_log(format!("✗ Failed to launch: {}", error_msg));
                        return Err(error_msg);
                    }

                    self.add_log("✓ Successfully launched program with elevation".to_string());
                    // Return 0 as we can't get PID from ShellExecute
                    return Ok(0);
                }
            }
        }

        // Standard launch without elevation
        use std::process::Command;

        let mut cmd = Command::new(program);

        // Parse and add arguments
        if !args.is_empty() {
            // Simple argument parsing - split by spaces
            // For more complex arguments, would need proper shell parsing
            for arg in args.split_whitespace() {
                cmd.arg(arg);
            }
        }

        // Set working directory to the program's directory
        // This fixes issues with programs like PowerShell
        if let Some(parent) = std::path::Path::new(program).parent() {
            if parent.exists() {
                cmd.current_dir(parent);
            }
        }

        // Spawn the process
        match cmd.spawn() {
            Ok(child) => {
                let pid = child.id();
                self.add_log(format!("✓ Successfully launched program with PID: {}", pid));
                Ok(pid)
            }
            Err(e) => {
                let error_msg = format!("✗ Failed to launch: {}", e);
                self.add_log(error_msg.clone());
                Err(error_msg)
            }
        }
    }
    fn get_config_path() -> std::path::PathBuf {
        // Check current directory first
        let current_dir_config = std::path::Path::new("vibe_winshell.ini");
        if current_dir_config.exists() {
            return current_dir_config.to_path_buf();
        }

        // Check ~/.config/vibe_winshell.ini
        if let Some(home_dir) = dirs::home_dir() {
            let config_dir = home_dir.join(".config");
            if !config_dir.exists() {
                let _ = std::fs::create_dir_all(&config_dir);
            }
            return config_dir.join("vibe_winshell.ini");
        }

        // Fallback to current directory
        std::path::PathBuf::from("vibe_winshell.ini")
    }

    fn load_config() -> AppConfig {
        let config_path = Self::get_config_path();
        let mut config = AppConfig {
            programs: Vec::new(),
            font_path: String::new(),
            use_noto: false,
            theme: Theme::Dark,
            live_grid_size: 3,
            live_detail_percent: 0.5,
            attempt_start_as_admin: true,
        };

        if let Ok(content) = std::fs::read_to_string(&config_path) {
            let mut current_program = CustomProgram {
                name: String::new(),
                path: String::new(),
                args: String::new(),
                admin: false,
            };
            let mut in_program = false;
            let mut in_settings = false;

            for line in content.lines() {
                let line = line.trim();
                if line.starts_with("[Program]") {
                    if in_program && !current_program.name.is_empty() && !current_program.path.is_empty() {
                        config.programs.push(current_program.clone());
                    }
                    current_program = CustomProgram {
                        name: String::new(),
                        path: String::new(),
                        args: String::new(),
                        admin: false,
                    };
                    in_program = true;
                    in_settings = false;
                } else if line.starts_with("[Settings]") {
                    // Push potential previous program
                    if in_program && !current_program.name.is_empty() && !current_program.path.is_empty() {
                        config.programs.push(current_program.clone());
                    }
                    in_settings = true;
                    in_program = false;
                } else if in_program {
                    if let Some((key, value)) = line.split_once('=') {
                        let key = key.trim();
                        let value = value.trim();
                        match key {
                            "Name" => current_program.name = value.to_string(),
                            "Path" => current_program.path = value.to_string(),
                            "Args" => current_program.args = value.to_string(),
                            "Admin" => current_program.admin = value == "true",
                            _ => {}
                        }
                    }
                } else if in_settings {
                    if let Some((key, value)) = line.split_once('=') {
                        let key = key.trim();
                        let value = value.trim();
                        match key {
                            "FontPath" => config.font_path = value.to_string(),
                            "UseNoto" => config.use_noto = value == "true",
                            "Theme" => {
                                if value == "Light" {
                                    config.theme = Theme::Light;
                                } else {
                                    config.theme = Theme::Dark;
                                }
                            },
                            "LiveGridSize" => {
                                if let Ok(size) = value.parse() {
                                    config.live_grid_size = size;
                                }
                            },
                             "LiveDetailPercent" => {
                                if let Ok(p) = value.parse() {
                                    config.live_detail_percent = p;
                                }
                            },
                             "AttemptStartAsAdmin" => config.attempt_start_as_admin = value == "true",
                            _ => {}
                        }
                    }
                }
            }
            // Push last program
            if in_program && !current_program.name.is_empty() && !current_program.path.is_empty() {
                config.programs.push(current_program);
            }
        }

        config
    }

    fn save_config(&self) {
        let config_path = Self::get_config_path();
        let mut content = String::new();

        // Save Settings
        content.push_str("[Settings]\n");
        content.push_str(&format!("FontPath={}\n", self.font_path));
        content.push_str(&format!("UseNoto={}\n", self.use_noto_font));
        content.push_str(&format!("Theme={}\n", if self.theme == Theme::Light { "Light" } else { "Dark" }));
        content.push_str(&format!("LiveGridSize={}\n", self.live_grid_size));
        content.push_str(&format!("LiveDetailPercent={}\n", self.live_detail_percent));
        content.push_str(&format!("AttemptStartAsAdmin={}\n", self.attempt_start_as_admin));
        content.push_str("\n");

        // Save Programs
        for program in &self.custom_programs {
            content.push_str("[Program]\n");
            content.push_str(&format!("Name={}\n", program.name));
            content.push_str(&format!("Path={}\n", program.path));
            content.push_str(&format!("Args={}\n", program.args));
            content.push_str(&format!("Admin={}\n", program.admin));
            content.push_str("\n");
        }

        if let Err(e) = std::fs::write(&config_path, content) {
            eprintln!("Failed to save config: {}", e);
        }
    }

    fn add_custom_program(&mut self, name: String, path: String, args: String, admin: bool) {
        // Check if already exists
        if !self.custom_programs.iter().any(|p| p.path == path && p.args == args) {
            self.custom_programs.push(CustomProgram {
                name,
                path,
                args,
                admin,
            });
            self.save_config();
            self.add_log("Added new custom program".to_string());
        } else {
            self.add_log("Program already exists in custom list".to_string());
        }
    }
}
